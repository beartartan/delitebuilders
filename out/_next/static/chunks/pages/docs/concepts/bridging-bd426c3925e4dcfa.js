(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3028],{277:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/concepts/bridging",function(){return n(8065)}])},2851:function(e,t,n){"use strict";n.d(t,{Z:function(){return l}});var i=n(1527),r=n(5941),o=n.n(r),a=n(6607),s=n(959),d=n(7669),c=n(3283),l={banner:{key:"banner",text:(0,i.jsx)("a",{href:"/docs/guides",target:"_blank",children:"\uD83D\uDCCC Alpha-3 is here! Get started →"})},chat:{link:"https://discord.gg/delitesystems"},darkMode:!0,docsRepositoryBase:"https://github.com/delitesystems/delite-mono/blob/main/packages/website",editLink:{text:"Edit this page ↗"},feedback:{content:null},footer:{component:function(){return(0,i.jsx)("footer",{className:"bg-neutral-100 dark:bg-neutral-900",children:(0,i.jsxs)("div",{className:"mx-auto max-w-[90rem] pl-3",children:[(0,i.jsxs)("div",{className:"grid grid-cols-2 pl-[max(env(safe-area-inset-left),1.5rem)] pr-[max(env(safe-area-inset-right),1.5rem)] py-8 md:grid-cols-3",children:[(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{className:"font-grotesk mb-6 text-lg text-neutral-500 dark:text-neutral-300 pt-3",children:"About"}),(0,i.jsxs)("ul",{className:"text-neutral-500 dark:text-neutral-400",children:[(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://mirror.xyz/labs.delite.eth",className:"hover:underline",target:"_blank",children:"Blog"})}),(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://www.notion.so/delitesystems/Delite-Jobs-828fd7232d2c4150a11e10c8baa910a2",className:"hover:underline",target:"_blank",children:"Careers"})}),(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://github.com/delitesystems/delite-mono/tree/main/packages/branding/",className:"hover:underline",target:"_blank",children:"Media kit"})})]})]}),(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{className:"font-grotesk mb-6 text-lg text-neutral-500 dark:text-neutral-300 pt-3",children:"Developers"}),(0,i.jsxs)("ul",{className:"text-neutral-500 dark:text-neutral-400",children:[(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"/docs",className:"hover:underline",children:"Get started"})}),(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://github.com/delitesystems",className:"hover:underline",target:"_blank",children:"GitHub"})}),(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://delitesystems.github.io/delite-mono/delite-whitepaper.pdf",className:"hover:underline",target:"_blank",children:"Whitepaper"})})]})]}),(0,i.jsxs)("div",{children:[(0,i.jsx)("h2",{className:"font-grotesk mb-6 text-lg text-neutral-500 dark:text-neutral-300 pt-3",children:"Follow us"}),(0,i.jsxs)("ul",{className:"text-neutral-500 dark:text-neutral-400",children:[(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://discord.gg/delitesystems",className:"hover:underline",target:"_blank",children:"Discord"})}),(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://twitter.com/delitesystems",className:"hover:underline",target:"_blank",children:"Twitter"})}),(0,i.jsx)("li",{className:"mb-4",children:(0,i.jsx)("a",{href:"https://www.youtube.com/@delitesystems",className:"hover:underline",target:"_blank",children:"YouTube"})})]})]})]}),(0,i.jsxs)("div",{className:"font-groteskmedium text-md text-center text-neutral-500 dark:text-neutral-300 bg-neutral-100 dark:bg-neutral-900 px-4 py-6",children:["\xa9 ",new Date().getFullYear()," Delite Labs"]})]})})}},head:()=>{let{asPath:e}=(0,c.useRouter)(),{frontMatter:t}=(0,d.ZR)();return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("meta",{property:"og:url",content:"https://delite.xyz".concat(e)}),(0,i.jsx)("meta",{property:"og:title",content:t.title||"Delite"}),(0,i.jsx)("meta",{property:"og:description",content:t.description||"A decentralized, Ethereum-equivalent ZK-Rollup."}),(0,i.jsx)("meta",{property:"og:image",content:"/images/Delite_social_media_preview.png"}),(0,i.jsx)("link",{rel:"icon",href:"/images/favicon.svg"})]})},logo:(0,i.jsx)(function(){let{resolvedTheme:e}=(0,a.F)(),[t,n]=(0,s.useState)(null);return(0,s.useEffect)(()=>{n("dark"===e?"/images/logotype-white.png":"/images/logotype-black.png")},[e]),t?(0,i.jsx)(o(),{src:t,width:100,height:100,alt:"logo",style:{width:"100%",height:"auto"}}):null},{}),nextThemes:{defaultTheme:"light"},primaryHue:323,project:{link:"https://github.com/delitesystems"},useNextSeoProps:()=>({titleTemplate:"%s – Delite"})}},8065:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return m}});var i=n(1527),r=n(30),o=n(7669),a=n(2851);n(6114),n(7742);var s=n(6736),d=n(5941),c=n.n(d),l={src:"/_next/static/media/bridging-send-message.7cf2428a.png",height:1536,width:1267,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAMAAAAC2hU0AAAAVFBMVEX////+/v79/f38/f38/Pz8/Pv6/P76/P37+/v6+vr5+fn4+Pn4+Pj3+Pn49/f39/f29vf29vby9vn09ffy8/X08vT28fL56+7v7fPm7/ji7Pbh7PaS0vlDAAAAPElEQVR42g3FRxaAIBBEwU9jgAFz1vvf03m1KEo1y0FMmVkEQHv0RXw7323F8PtvaANpOY91rDTpuh/pBy9rAcul0GKiAAAAAElFTkSuQmCC",blurWidth:7,blurHeight:8},h={src:"/_next/static/media/bridging-process-message.2ff2e73a.png",height:1467,width:1245,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAMAAAAC2hU0AAAAZlBMVEX////+/v79/v79/f79/f38/f79/Pz8/Pz7/P39+/z8/Pn8+/v7+/v6+/35+/37+vr6+vr5+fr5+fn3+Pjy9vr19fb19fX58/Tw9fv09PTz9PXz8/Pz8vPy8fHx8O/j7Pbi6vP04ui6u92eAAAAQElEQVR42g3HxxGAMBADQB0ITA4Ck2P/Tdqzr8UoDXLEtbjJQOjcH8Ki9suQwupjS+L4r1Xf5LDSz/4WiO4twABYPAKvfog2hwAAAABJRU5ErkJggg==",blurWidth:7,blurHeight:8};let g={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,s.ah)(),e.components);return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)},pageOpts:{filePath:"pages/docs/concepts/bridging.mdx",route:"/docs/concepts/bridging",headings:[{depth:1,value:"Bridging",id:"bridging"},{depth:2,value:"Cross-chain messaging",id:"cross-chain-messaging"},{depth:3,value:"Delite stores block hashes of each chain",id:"delite-stores-block-hashes-of-each-chain"},{depth:3,value:"Merkle trees enable verifying values exist on the other chain",id:"merkle-trees-enable-verifying-values-exist-on-the-other-chain"},{depth:2,value:"The signal service",id:"the-signal-service"},{depth:2,value:"How the bridge works",id:"how-the-bridge-works"},{depth:3,value:"How does Ether bridging work?",id:"how-does-ether-bridging-work"},{depth:3,value:"How does ERC-20 bridging work?",id:"how-does-erc-20-bridging-work"},{depth:4,value:"Bridge from canonical chain to destination chain",id:"bridge-from-canonical-chain-to-destination-chain"},{depth:4,value:"Bridge from destination chain back to the canonical chain",id:"bridge-from-destination-chain-back-to-the-canonical-chain"}],pageMap:[{kind:"Meta",data:{index:{display:"hidden",title:"Delite",type:"page",theme:{layout:"raw"}},docs:{title:"Docs",type:"page"},bridge:{title:"Bridge",type:"page",href:"https://bridge.test.delite.xyz",newWindow:!0},swap:{title:"Swap",type:"page",display:"hidden",href:"https://swap.test.delite.xyz",newWindow:!0},explorers:{title:"Explorers",type:"menu",items:{status:{title:"Protocol Status",href:"https://status.test.delite.xyz",newWindow:!0},"l1-block-explorer":{title:"L1 Block Explorer",href:"https://sepolia.etherscan.io",newWindow:!0},"l2-block-explorer":{title:"L2 Block Explorer",href:"https://explorer.test.delite.xyz",newWindow:!0}}},ecosystem:{title:"Ecosystem",type:"page",theme:{layout:"full"}},blog:{title:"Blog",type:"page",href:"https://mirror.xyz/labs.delite.eth",newWindow:!0},forum:{title:"Forum",type:"page",href:"https://community.delite.xyz/",newWindow:!0},feedback:{title:"Feedback",type:"page",href:"https://forms.gle/9JWjWtjbWytZZcNRA",newWindow:!0}}},{kind:"Folder",name:"docs",route:"/docs",children:[{kind:"Meta",data:{index:{title:"Hello \uD83D\uDC4B"},guides:{title:"Guides"},reference:{title:"Reference"},concepts:{title:"Concepts"},resources:{title:"Resources"}}},{kind:"Folder",name:"concepts",route:"/docs/concepts",children:[{kind:"Meta",data:{overview:{title:"Overview"},proposing:{title:"Proposing Delite blocks"},proving:{title:"Proving Delite blocks"},bridging:{title:"Bridging"},"delite-nodes":{title:"Delite nodes"},"taiko-nodes":"Taiko Nodes"}},{kind:"MdxPage",name:"bridging",route:"/docs/concepts/bridging"},{kind:"MdxPage",name:"overview",route:"/docs/concepts/overview"},{kind:"MdxPage",name:"proposing",route:"/docs/concepts/proposing"},{kind:"MdxPage",name:"proving",route:"/docs/concepts/proving"},{kind:"MdxPage",name:"taiko-nodes",route:"/docs/concepts/taiko-nodes"}]},{kind:"Folder",name:"guides",route:"/docs/guides",children:[{kind:"Meta",data:{"configure-your-wallet":{title:"\uD83D\uDCBB Configure your wallet"},"receive-tokens":{title:"\uD83C\uDF88 Receive tokens"},"use-the-bridge":{title:"\uD83C\uDF09 Use the bridge"},"swap-tokens":{title:"\uD83D\uDD04 Swap tokens"},"run-a-node":{title:"\uD83C\uDF10 Run a node"},"enable-a-proposer":{title:"\uD83D\uDCE4 Enable a proposer"},"enable-a-prover":{title:"✅ Enable a prover"},"deploy-a-contract":{title:"\uD83D\uDE80 Deploy a contract"},"verify-a-contract":{title:"\uD83D\uDCDC Verify a contract"},"build-a-dapp":{title:"\uD83D\uDEE0️ Build a dapp"}}},{kind:"MdxPage",name:"build-a-dapp",route:"/docs/guides/build-a-dapp"},{kind:"MdxPage",name:"configure-your-wallet",route:"/docs/guides/configure-your-wallet"},{kind:"MdxPage",name:"deploy-a-contract",route:"/docs/guides/deploy-a-contract"},{kind:"MdxPage",name:"enable-a-proposer",route:"/docs/guides/enable-a-proposer"},{kind:"MdxPage",name:"enable-a-prover",route:"/docs/guides/enable-a-prover"},{kind:"MdxPage",name:"receive-tokens",route:"/docs/guides/receive-tokens"},{kind:"MdxPage",name:"run-a-node",route:"/docs/guides/run-a-node"},{kind:"MdxPage",name:"swap-tokens",route:"/docs/guides/swap-tokens"},{kind:"MdxPage",name:"use-the-bridge",route:"/docs/guides/use-the-bridge"},{kind:"MdxPage",name:"verify-a-contract",route:"/docs/guides/verify-a-contract"}]},{kind:"MdxPage",name:"guides",route:"/docs/guides"},{kind:"MdxPage",name:"index",route:"/docs"},{kind:"Folder",name:"reference",route:"/docs/reference",children:[{kind:"Meta",data:{"contract-documentation":{title:"Contract documentation"},"contract-addresses":{title:"Contract addresses"},"rpc-configuration":{title:"RPC configuration"}}},{kind:"MdxPage",name:"contract-addresses",route:"/docs/reference/contract-addresses"},{kind:"Folder",name:"contract-documentation",route:"/docs/reference/contract-documentation",children:[{kind:"Folder",name:"L1",route:"/docs/reference/contract-documentation/L1",children:[{kind:"MdxPage",name:"TaikoConfig",route:"/docs/reference/contract-documentation/L1/TaikoConfig",frontMatter:{title:"DeliteConfig"}},{kind:"MdxPage",name:"TaikoData",route:"/docs/reference/contract-documentation/L1/TaikoData",frontMatter:{title:"DeliteData"}},{kind:"MdxPage",name:"TaikoErrors",route:"/docs/reference/contract-documentation/L1/TaikoErrors",frontMatter:{title:"DeliteErrors"}},{kind:"MdxPage",name:"TaikoEvents",route:"/docs/reference/contract-documentation/L1/TaikoEvents",frontMatter:{title:"DeliteEvents"}},{kind:"MdxPage",name:"TaikoL1",route:"/docs/reference/contract-documentation/L1/TaikoL1",frontMatter:{title:"DeliteL1"}},{kind:"MdxPage",name:"TaikoToken",route:"/docs/reference/contract-documentation/L1/TaikoToken",frontMatter:{title:"LibDeliteTokenConfig"}},{kind:"Meta",data:{TaikoConfig:"DeliteConfig",TaikoData:"DeliteData",TaikoErrors:"DeliteErrors",TaikoEvents:"DeliteEvents",TaikoL1:"DeliteL1",TaikoToken:"LibDeliteTokenConfig"}}]},{kind:"Folder",name:"L2",route:"/docs/reference/contract-documentation/L2",children:[{kind:"MdxPage",name:"LibL2Consts",route:"/docs/reference/contract-documentation/L2/LibL2Consts",frontMatter:{title:"LibL2Consts"}},{kind:"MdxPage",name:"TaikoL2",route:"/docs/reference/contract-documentation/L2/TaikoL2",frontMatter:{title:"DeliteL2"}},{kind:"MdxPage",name:"TaikoL2Signer",route:"/docs/reference/contract-documentation/L2/TaikoL2Signer",frontMatter:{title:"DeliteL2Signer"}},{kind:"Meta",data:{TaikoL2:"DeliteL2",TaikoL2Signer:"DeliteL2Signer",LibL2Consts:"LibL2Consts"}}]},{kind:"Folder",name:"bridge",route:"/docs/reference/contract-documentation/bridge",children:[{kind:"MdxPage",name:"Bridge",route:"/docs/reference/contract-documentation/bridge/Bridge",frontMatter:{title:"Bridge"}},{kind:"MdxPage",name:"BridgeErrors",route:"/docs/reference/contract-documentation/bridge/BridgeErrors",frontMatter:{title:"BridgeErrors"}},{kind:"MdxPage",name:"BridgedERC20",route:"/docs/reference/contract-documentation/bridge/BridgedERC20",frontMatter:{title:"BridgedERC20"}},{kind:"MdxPage",name:"EtherVault",route:"/docs/reference/contract-documentation/bridge/EtherVault",frontMatter:{title:"EtherVault"}},{kind:"MdxPage",name:"IBridge",route:"/docs/reference/contract-documentation/bridge/IBridge",frontMatter:{title:"IBridge"}},{kind:"MdxPage",name:"TokenVault",route:"/docs/reference/contract-documentation/bridge/TokenVault",frontMatter:{title:"TokenVault"}},{kind:"Meta",data:{Bridge:"Bridge",BridgedERC20:"BridgedERC20",BridgeErrors:"BridgeErrors",EtherVault:"EtherVault",IBridge:"IBridge",TokenVault:"TokenVault"}}]},{kind:"Folder",name:"common",route:"/docs/reference/contract-documentation/common",children:[{kind:"MdxPage",name:"AddressManager",route:"/docs/reference/contract-documentation/common/AddressManager",frontMatter:{title:"IAddressManager"}},{kind:"MdxPage",name:"AddressResolver",route:"/docs/reference/contract-documentation/common/AddressResolver",frontMatter:{title:"AddressResolver"}},{kind:"MdxPage",name:"ICrossChainSync",route:"/docs/reference/contract-documentation/common/ICrossChainSync",frontMatter:{title:"ICrossChainSync"}},{kind:"MdxPage",name:"IMintableERC20",route:"/docs/reference/contract-documentation/common/IMintableERC20",frontMatter:{title:"IMintableERC20"}},{kind:"MdxPage",name:"Proxied",route:"/docs/reference/contract-documentation/common/Proxied",frontMatter:{title:"Proxied"}},{kind:"Meta",data:{AddressResolver:"AddressResolver",AddressManager:"IAddressManager",ICrossChainSync:"ICrossChainSync",IMintableERC20:"IMintableERC20",Proxied:"Proxied"}}]},{kind:"Folder",name:"gov",route:"/docs/reference/contract-documentation/gov",children:[{kind:"MdxPage",name:"TaikoGovernor",route:"/docs/reference/contract-documentation/gov/TaikoGovernor",frontMatter:{title:"DeliteGovernor"}},{kind:"Meta",data:{TaikoGovernor:"DeliteGovernor"}}]},{kind:"Folder",name:"signal",route:"/docs/reference/contract-documentation/signal",children:[{kind:"MdxPage",name:"ISignalService",route:"/docs/reference/contract-documentation/signal/ISignalService",frontMatter:{title:"ISignalService"}},{kind:"MdxPage",name:"SignalService",route:"/docs/reference/contract-documentation/signal/SignalService",frontMatter:{title:"SignalService"}},{kind:"Meta",data:{ISignalService:"ISignalService",SignalService:"SignalService"}}]}]},{kind:"MdxPage",name:"rpc-configuration",route:"/docs/reference/rpc-configuration"}]},{kind:"Folder",name:"resources",route:"/docs/resources",children:[{kind:"Meta",data:{contributing:{title:"Contributing"},"official-links":{title:"Official links"},talks:{title:"Talks"},"rollup-glossary":{title:"Rollup glossary"},whitepaper:{title:"Whitepaper"}}},{kind:"MdxPage",name:"contributing",route:"/docs/resources/contributing"},{kind:"MdxPage",name:"official-links",route:"/docs/resources/official-links"},{kind:"MdxPage",name:"rollup-glossary",route:"/docs/resources/rollup-glossary"},{kind:"MdxPage",name:"talks",route:"/docs/resources/talks"},{kind:"MdxPage",name:"whitepaper",route:"/docs/resources/whitepaper"}]}]},{kind:"MdxPage",name:"ecosystem",route:"/ecosystem"},{kind:"MdxPage",name:"index",route:"/",frontMatter:{title:"Home"}}],flexsearch:{codeblocks:!0},title:"Bridging"},pageNextRoute:"/docs/concepts/bridging",nextraLayout:o.ZP,themeConfig:a.Z};function u(e){let t=Object.assign({h1:"h1",p:"p",ul:"ul",li:"li",a:"a",h2:"h2",h3:"h3",code:"code",strong:"strong",ol:"ol",br:"br",h4:"h4"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{children:"Bridging"}),"\n",(0,i.jsx)(t.p,{children:"Bridges are foundational for cross-chain users and applications. Users might come to another chain, such as Delite (a ZK-rollup). To do this, they need to bridge over funds. Notoriously, bridging has been a dangerous operation. How do you make sure that this bridge is secure?"}),"\n",(0,i.jsx)(t.p,{children:"Let's explain bridging on Delite. We will answer the following questions:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#cross-chain-messaging",children:"How does the Delite protocol enable secure cross-chain messaging?"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#the-signal-service",children:"What is the Delite signal service?"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#how-the-bridge-works",children:"How does Delite's bridge implementation work?"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"cross-chain-messaging",children:"Cross-chain messaging"}),"\n",(0,i.jsx)(t.p,{children:"The Delite protocol's design, specifically its Ethereum-equivalence enables secure cross-chain messaging. Let's see how it works by simply using merkle proofs."}),"\n",(0,i.jsx)(t.h3,{id:"delite-stores-block-hashes-of-each-chain",children:"Delite stores block hashes of each chain"}),"\n",(0,i.jsx)(t.p,{children:"Delite deploys two smart contracts which store the hashes of the other chain:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["DeliteL1 stores a blockNumber->blockHash mapping ",(0,i.jsx)(t.code,{children:"l2Hashes"})," (deployed on Ethereum)"]}),"\n",(0,i.jsxs)(t.li,{children:["DeliteL2 stores a blockNumber->blockHash mapping ",(0,i.jsx)(t.code,{children:"l1Hashes"})," (deployed on Delite)"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Every time an L2 block is created on Delite, the hash of the enclosing block on L1 is stored in the DeliteL2 contract. And every time an L1 block is verified, the L2 hash is stored in the DeliteL1 contract (only the latest one, if multiple ones are verified at once)."}),"\n",(0,i.jsx)(t.h3,{id:"merkle-trees-enable-verifying-values-exist-on-the-other-chain",children:"Merkle trees enable verifying values exist on the other chain"}),"\n",(0,i.jsx)(t.p,{children:"Merkle trees are a data storage structure that allows a lot of data to be fingerprinted with a single hash, called the merkle root. The way that they are structured enables one to verify that some value exists within this large data structure, without actually needing to have access to the entire merkle tree. To do this, the verifier would need:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'The merkle root, this is the single "fingerprint" hash of the merkle tree'}),"\n",(0,i.jsx)(t.li,{children:"The value, this is the value we are checking is inside the merkle root"}),"\n",(0,i.jsx)(t.li,{children:"A list of intermediate sibling hashes, these are the hashes that enable the verifier to re-calculate the merkle root"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["You can get the latest known merkle root stored on the destination chain by calling ",(0,i.jsx)(t.code,{children:"getCrossChainBlockHash(0)"})," on the DeliteL1/DeliteL2 contract. You can get the value / message to verify and the sibling hashes for that latest known merkle root by asking for it with the standard RPC call ",(0,i.jsx)(t.code,{children:"eth_getProof"}),' on the "source chain". Then you just need to send them to be verified against that latest known block hash that is stored in a list on the "destination chain".']}),"\n",(0,i.jsx)(t.p,{children:"A verifier will take the value (a leaf in the merkle tree) and the sibling hashes to re-calculate the merkle root. If the calculated merkle root matches the one that is stored in the destination chain's list of block hashes (the block hashes of the source chain), then we have proved that the message was sent on the source chain, assuming the source chain block hashes stored on the destination chain were correct."}),"\n",(0,i.jsx)(t.h2,{id:"the-signal-service",children:"The signal service"}),"\n",(0,i.jsxs)(t.p,{children:["Delite's signal service is a smart contract available on both L1 and L2, available for any dapp developer to use. It exposes a ",(0,i.jsx)(t.a,{href:"/docs/reference/contract-documentation/signal/ISignalService",children:"simple interface"}),". And it's what uses the previously mentioned merkle proofs to provide a service for secure cross-chain messaging."]}),"\n",(0,i.jsxs)(t.p,{children:["You can store signals and check if a signal was sent from an address. It also exposes one more important function: ",(0,i.jsx)(t.code,{children:"isSignalReceived"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"What does this function do? The first thing to understand is that the Delite protocol maintains two important contracts:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/reference/contract-documentation/L1/DeliteL1",children:"DeliteL1"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/reference/contract-documentation/L2/DeliteL2",children:"DeliteL2"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["These contracts both keep track of the block hashes on the ",(0,i.jsx)(t.strong,{children:"other chain"}),". So DeliteL1, which is deployed on Ethereum, has access to the latest block hashes on Delite. And DeliteL2, which is deployed on Delite, has access to the latest block hashes on Ethereum."]}),"\n",(0,i.jsxs)(t.p,{children:["So, ",(0,i.jsx)(t.code,{children:"isSignalReceived"})," can prove on either chain that you sent a signal to the Signal Service on the other chain. A user or dapp can call ",(0,i.jsx)(t.code,{children:"eth_getProof"}),"(",(0,i.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-1186",children:"https://eips.ethereum.org/EIPS/eip-1186"}),") which generates a merkle proof."]}),"\n",(0,i.jsxs)(t.p,{children:["You need to provide ",(0,i.jsx)(t.code,{children:"eth_getProof"})," with:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The signal (the data you want to prove exists within the storage root of some block on the chain)"}),"\n",(0,i.jsx)(t.li,{children:"The address of the signal service (the contract address which stores the provided signal)"}),"\n",(0,i.jsx)(t.li,{children:"The block number you are asserting the signal was sent on (optional—if you don't provide this, it will default to the latest block number)"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["And, ",(0,i.jsx)(t.code,{children:"eth_getProof"})," will generate a merkle proof (it will give the necessary sibling hashes and the height of the block, that along with the signal, can rebuild the merkle storage root of the block you are asserting the signal exists in)."]}),"\n",(0,i.jsxs)(t.p,{children:["This means, assuming that the hashes which DeliteL1 and DeliteL2 maintain are correct, we can reliably send ",(0,i.jsx)(t.strong,{children:"cross-chain messages"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Let's walk through an example:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"First, we can send a message on some source chain, and store it on the signal service."}),"\n",(0,i.jsxs)(t.li,{children:["Next, we call ",(0,i.jsx)(t.code,{children:"eth_getProof"}),", which will give us a proof that we did indeed send a message on the source chain."]}),"\n",(0,i.jsxs)(t.li,{children:["Finally, we call ",(0,i.jsx)(t.code,{children:"isSignalReceived"})," on the destination chain's SignalService which essentially just verifies the merkle proof. ",(0,i.jsx)(t.code,{children:"isSignalReceived"})," will look up the block hash you are asserting you had stored a message on the source chain (where you originally sent the message), and with the sibling hashes inside the merkle proof it will rebuild the merkle root, which verifies the signal was included in that merkle root—meaning it was sent."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"And boom! We have sent a cross-chain message. Confusing? Well leave some feedback please if it is, so we can clear it up."}),"\n",(0,i.jsx)(t.h2,{id:"how-the-bridge-works",children:"How the bridge works"}),"\n",(0,i.jsxs)(t.p,{children:["The bridge is a set of smart contracts and a frontend web app that allow you to send testnet ETH and ERC-20 tokens between Sepolia and Delite. This bridge is just one possible implementation built on top of Delite's core protocol, specifically the signal service which anybody can use to build bridges. You can try the bridge ",(0,i.jsx)(t.a,{href:"https://bridge.test.delite.xyz",children:"here"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"First, here is a flowchart of how our bridge dapp implementation works, which uses the signal service:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(c(),{alt:"bridging send message flowchart",placeholder:"blur",src:l})," ",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(c(),{alt:"bridging process message flowchart",placeholder:"blur",src:h})]}),"\n",(0,i.jsx)(t.h3,{id:"how-does-ether-bridging-work",children:"How does Ether bridging work?"}),"\n",(0,i.jsx)(t.p,{children:"Delite's bridge utilizes the Signal Service we described. Here is the general user flow for Delite's bridge:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The user sends their funds to the Bridge contract"}),"\n",(0,i.jsxs)(t.li,{children:["The Bridge locks the Ether, and stores a message by calling ",(0,i.jsx)(t.code,{children:"sendSignal(message)"})," on the SignalService contract"]}),"\n",(0,i.jsx)(t.li,{children:"The user receives Ether on the destination chain, if they (or another) provide a valid merkle proof that the message was received on the source chain"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"how-does-erc-20-bridging-work",children:"How does ERC-20 bridging work?"}),"\n",(0,i.jsx)(t.p,{children:"ERC-20 tokens originate from a canonical chain. To send a token and bridge it to the other chain, a new BridgedERC20 contract needs to be deployed on the destination chain."}),"\n",(0,i.jsx)(t.h4,{id:"bridge-from-canonical-chain-to-destination-chain",children:"Bridge from canonical chain to destination chain"}),"\n",(0,i.jsx)(t.p,{children:"Here are the overall steps for transferring canonical ERC-20 from a source chain to the destination chain:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"A contract for the ERC-20 must first be deployed on the destination chain (will be done automatically by the TokenVault if not already deployed)"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Call sendERC20 on the source chain TokenVault, this will ",(0,i.jsx)(t.strong,{children:"transfer"})," the amount by using the ",(0,i.jsx)(t.code,{children:"safeTransferFrom"})," function on the canonical ERC-20 contract, on the source chain, to the TokenVault."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Send a message to the Signal Service (on the source chain), this message will contain some metadata related to the bridge request, but most importantly it includes the calldata for the ",(0,i.jsx)(t.code,{children:"receiveERC20"})," method."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Process the message on the destination chain by submitting a merkle proof (generated from the source chain), proving that a message is included in the state of the source chain Signal Service. After verifying this occurred and doing some checks, it will attempt to invoke the ",(0,i.jsx)(t.code,{children:"receiveERC20"})," method encoded in the message. This will ",(0,i.jsx)(t.strong,{children:"mint"})," ERC-20 on the BridgedERC20 contract to the ",(0,i.jsx)(t.code,{children:"to"})," address on the destination chain!"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"bridge-from-destination-chain-back-to-the-canonical-chain",children:"Bridge from destination chain back to the canonical chain"}),"\n",(0,i.jsx)(t.p,{children:"Okay now let's do the reverse, how do we transfer a bridged token from a source chain to the destination chain?"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"A contract for the ERC-20 already exists on the canonical chain, so no need to deploy a new one."}),"\n",(0,i.jsxs)(t.li,{children:["Call sendERC20 on the source chain TokenVault, this will ",(0,i.jsx)(t.strong,{children:"burn"})," the ERC-20 on the BridgedERC20 contract."]}),"\n",(0,i.jsxs)(t.li,{children:["Send a message to the Signal Service (on the source chain), this message will contain some metadata related to the bridge request, but most importantly it includes the calldata for the ",(0,i.jsx)(t.code,{children:"receiveERC20"})," method."]}),"\n",(0,i.jsxs)(t.li,{children:["Process the message on the destination chain by submitting a merkle proof (generated from the source chain), proving that a message is included in the state of the source chain Signal Service. After verifying this occurred and doing some checks, it will attempt to invoke the ",(0,i.jsx)(t.code,{children:"receiveERC20"})," method encoded in this message. This will ",(0,i.jsx)(t.strong,{children:"transfer"})," the amount from the destination chain TokenVault to the ",(0,i.jsx)(t.code,{children:"to"})," address on the destination chain."]}),"\n"]})]})}var m=(0,r.j)(g)}},function(e){e.O(0,[4735,9774,2888,179],function(){return e(e.s=277)}),_N_E=e.O()}]);