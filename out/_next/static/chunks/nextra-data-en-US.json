{"/docs/concepts/overview":{"title":"Overview","data":{"":"","overview#Overview":"Delite aims to build a secure, decentralized, and permissionless rollup on Ethereum. These requirements dictate the following properties:\nAll block data required to reconstruct the post-block state needs to be put on Ethereum so it is publicly available. If this would not be the case, Delite would not only fail to be a rollup but would also fail to be fully decentralized. This data is required so that anyone can know the latest chain state and so that useful new blocks can be appended to the chain. For the decentralization of the proof generation Delite requires an even stronger requirement: all block data needed to be able to re-execute all work in a block in a step-by-step fashion needs to be made public. This makes it possible for provers to generate a proof for a block using only publicly known data.\nCreating and proposing blocks should be a fast and efficient process. Anyone should be able to add blocks to the chain on a level playing field, having access to the same chain data at all times. Proposers, of course, should be able to compete on e.g. transaction fees and Maximal Extractable Value (MEV).\n\nWe achieve this by splitting the block submission process in two parts:","block-proposal#Block proposal":"When a block gets proposed the block data is published on Ethereum and the block is appended to the proposed blocks list stored in the DeliteL1 contract. Once registered, the protocol ensures that all block properties are immutable. This makes the block execution deterministic: the post-block state can now be calculated by anyone. As such, the block is immediately verified. This also ensures that no one knows more about the latest state than anyone else, as that would create an unfair advantage.","block-verification#Block verification":"Because the block should already be verified once proposed, it should not be possible for the prover to have any impact on how the block is executed and what the post-block state is. All relevant inputs for the proof generation are verified on L1 directly or indirectly to achieve deterministic block transitions. As all proposed blocks are deterministic, they can be proven in parallel, because all intermediate states between blocks are known and unique. Once a proof is submitted for the block and its parent block, we call the block on-chain verified."}},"/docs/concepts/bridging":{"title":"Bridging","data":{"":"Bridges are foundational for cross-chain users and applications. Users might come to another chain, such as Delite (a ZK-rollup). To do this, they need to bridge over funds. Notoriously, bridging has been a dangerous operation. How do you make sure that this bridge is secure?Let's explain bridging on Delite. We will answer the following questions:\nHow does the Delite protocol enable secure cross-chain messaging?\nWhat is the Delite signal service?\nHow does Delite's bridge implementation work?","cross-chain-messaging#Cross-chain messaging":"The Delite protocol's design, specifically its Ethereum-equivalence enables secure cross-chain messaging. Let's see how it works by simply using merkle proofs.","delite-stores-block-hashes-of-each-chain#Delite stores block hashes of each chain":"Delite deploys two smart contracts which store the hashes of the other chain:\nDeliteL1 stores a blockNumber->blockHash mapping l2Hashes (deployed on Ethereum)\nDeliteL2 stores a blockNumber->blockHash mapping l1Hashes (deployed on Delite)\n\nEvery time an L2 block is created on Delite, the hash of the enclosing block on L1 is stored in the DeliteL2 contract. And every time an L1 block is verified, the L2 hash is stored in the DeliteL1 contract (only the latest one, if multiple ones are verified at once).","merkle-trees-enable-verifying-values-exist-on-the-other-chain#Merkle trees enable verifying values exist on the other chain":"Merkle trees are a data storage structure that allows a lot of data to be fingerprinted with a single hash, called the merkle root. The way that they are structured enables one to verify that some value exists within this large data structure, without actually needing to have access to the entire merkle tree. To do this, the verifier would need:\nThe merkle root, this is the single \"fingerprint\" hash of the merkle tree\nThe value, this is the value we are checking is inside the merkle root\nA list of intermediate sibling hashes, these are the hashes that enable the verifier to re-calculate the merkle root\n\nYou can get the latest known merkle root stored on the destination chain by calling getCrossChainBlockHash(0) on the DeliteL1/DeliteL2 contract. You can get the value / message to verify and the sibling hashes for that latest known merkle root by asking for it with the standard RPC call eth_getProof on the \"source chain\". Then you just need to send them to be verified against that latest known block hash that is stored in a list on the \"destination chain\".A verifier will take the value (a leaf in the merkle tree) and the sibling hashes to re-calculate the merkle root. If the calculated merkle root matches the one that is stored in the destination chain's list of block hashes (the block hashes of the source chain), then we have proved that the message was sent on the source chain, assuming the source chain block hashes stored on the destination chain were correct.","the-signal-service#The signal service":"Delite's signal service is a smart contract available on both L1 and L2, available for any dapp developer to use. It exposes a simple interface. And it's what uses the previously mentioned merkle proofs to provide a service for secure cross-chain messaging.You can store signals and check if a signal was sent from an address. It also exposes one more important function: isSignalReceived.What does this function do? The first thing to understand is that the Delite protocol maintains two important contracts:\nDeliteL1\nDeliteL2\n\nThese contracts both keep track of the block hashes on the other chain. So DeliteL1, which is deployed on Ethereum, has access to the latest block hashes on Delite. And DeliteL2, which is deployed on Delite, has access to the latest block hashes on Ethereum.So, isSignalReceived can prove on either chain that you sent a signal to the Signal Service on the other chain. A user or dapp can call eth_getProof(https://eips.ethereum.org/EIPS/eip-1186) which generates a merkle proof.You need to provide eth_getProof with:\nThe signal (the data you want to prove exists within the storage root of some block on the chain)\nThe address of the signal service (the contract address which stores the provided signal)\nThe block number you are asserting the signal was sent on (optional—if you don't provide this, it will default to the latest block number)\n\nAnd, eth_getProof will generate a merkle proof (it will give the necessary sibling hashes and the height of the block, that along with the signal, can rebuild the merkle storage root of the block you are asserting the signal exists in).This means, assuming that the hashes which DeliteL1 and DeliteL2 maintain are correct, we can reliably send cross-chain messages.Let's walk through an example:\nFirst, we can send a message on some source chain, and store it on the signal service.\nNext, we call eth_getProof, which will give us a proof that we did indeed send a message on the source chain.\nFinally, we call isSignalReceived on the destination chain's SignalService which essentially just verifies the merkle proof. isSignalReceived will look up the block hash you are asserting you had stored a message on the source chain (where you originally sent the message), and with the sibling hashes inside the merkle proof it will rebuild the merkle root, which verifies the signal was included in that merkle root—meaning it was sent.\n\nAnd boom! We have sent a cross-chain message. Confusing? Well leave some feedback please if it is, so we can clear it up.","how-the-bridge-works#How the bridge works":"The bridge is a set of smart contracts and a frontend web app that allow you to send testnet ETH and ERC-20 tokens between Sepolia and Delite. This bridge is just one possible implementation built on top of Delite's core protocol, specifically the signal service which anybody can use to build bridges. You can try the bridge here.First, here is a flowchart of how our bridge dapp implementation works, which uses the signal service:","how-does-ether-bridging-work#How does Ether bridging work?":"Delite's bridge utilizes the Signal Service we described. Here is the general user flow for Delite's bridge:\nThe user sends their funds to the Bridge contract\nThe Bridge locks the Ether, and stores a message by calling sendSignal(message) on the SignalService contract\nThe user receives Ether on the destination chain, if they (or another) provide a valid merkle proof that the message was received on the source chain","how-does-erc-20-bridging-work#How does ERC-20 bridging work?":"ERC-20 tokens originate from a canonical chain. To send a token and bridge it to the other chain, a new BridgedERC20 contract needs to be deployed on the destination chain.","bridge-from-canonical-chain-to-destination-chain#Bridge from canonical chain to destination chain":"Here are the overall steps for transferring canonical ERC-20 from a source chain to the destination chain:\nA contract for the ERC-20 must first be deployed on the destination chain (will be done automatically by the TokenVault if not already deployed)\nCall sendERC20 on the source chain TokenVault, this will transfer the amount by using the safeTransferFrom function on the canonical ERC-20 contract, on the source chain, to the TokenVault.\nSend a message to the Signal Service (on the source chain), this message will contain some metadata related to the bridge request, but most importantly it includes the calldata for the receiveERC20 method.\nProcess the message on the destination chain by submitting a merkle proof (generated from the source chain), proving that a message is included in the state of the source chain Signal Service. After verifying this occurred and doing some checks, it will attempt to invoke the receiveERC20 method encoded in the message. This will mint ERC-20 on the BridgedERC20 contract to the to address on the destination chain!","bridge-from-destination-chain-back-to-the-canonical-chain#Bridge from destination chain back to the canonical chain":"Okay now let's do the reverse, how do we transfer a bridged token from a source chain to the destination chain?\nA contract for the ERC-20 already exists on the canonical chain, so no need to deploy a new one.\nCall sendERC20 on the source chain TokenVault, this will burn the ERC-20 on the BridgedERC20 contract.\nSend a message to the Signal Service (on the source chain), this message will contain some metadata related to the bridge request, but most importantly it includes the calldata for the receiveERC20 method.\nProcess the message on the destination chain by submitting a merkle proof (generated from the source chain), proving that a message is included in the state of the source chain Signal Service. After verifying this occurred and doing some checks, it will attempt to invoke the receiveERC20 method encoded in this message. This will transfer the amount from the destination chain TokenVault to the to address on the destination chain."}},"/docs/concepts/proposing":{"title":"Proposing Delite blocks","data":{"":"","overview#Overview":"On Delite, the next L2 state is known immediately and deterministically at the time a block is proposed to the DeliteL1 contract. After a block is proposed, a series of checks are done to compute this post-L2 state:\nBlock is proposed by any proposer (permissionlessly).\nBlock level properties' validity is checked by the DeliteL1 contract with the (proposed block intrinsic validity function).\nProposed block is downloaded by a Delite node, and the transaction list is parsed over and checked for validity (transaction list intrinsic validity function).\nIF every transaction in the list is valid, an ordered subset of the list is created by skipping over transactions which have an invalid nonce or the sender has too little Ether balance to pay for the transaction. This ordered subset is used along with the anchor transaction to create a Delite L2 block.\nIF any transaction in the list is invalid, an empty block (with only the anchor tx) is created on L2.","intrinsic-validity-functions#Intrinsic validity functions":"The Ethereum yellow paper has a well defined set of rules to compute the state transition. We use these same rules to take a proposed block, and compute the post-block state on Delite. A proposed block on Delite has two parts:\nThe block metadata\nA list of transactions (stored in a blob, and the block metadata stores the hash to this blob)\n\nWe divide the yellow paper validity checks into two parts:\nProposed block intrinsic validity function\nTransaction list intrinsic validity function\n\nA proposed block must pass these two checks in order to map the txList to an L2 block on Delite. If a block passes the proposed block validity function but later fails the transaction list validity function, an empty block will be created.","proposed-block-intrinsic-validity-function#Proposed block intrinsic validity function":"The formal specification of the proposed block intrinsic can be found in the whitepaper, but on a high level, the proposed block intrinsic validity function checks that the block is valid except for transaction list validity checks. This is separated because on DeliteL1, the transaction list is not known and stored as a data blob. It would also be too expensive to do these checks on L1.\nName\tSymbol\tMeaning\tBlock Metadata\t\tThe block metadata.\tid\t\tA value equal to the number of proposed blocks. The genesis block has an id of zero.\tbeneficiary\t\tThe 20-byte address to which all transaction fees in the block will be transferred.\ttimestamp\t\tThe timestamp used in the block, set to the enclosing L1 timestamp.\tmixHash\t\tThe mixHash value used in the block, set to the enclosing L1 mixHash.\ttxListHash\t\tThe Keccak-256 hash of this block’s txList (KZG commitment after EIP-4844).\tl1Height\t\tThe enclosing L1 block’s parent block number.\tl1Hash\t\tThe enclosing L1 block’s parent block hash.\tDeliteL1\t\tThe DeliteL1 contract.\tnumProposedBlocks\t\tThe current number of proposed blocks (the id for the next proposed block is numProposedBlocks + 1).\tlastVerifiedBlockId\t\tThe last verified block id.\ttxList\t\tThe list of transactions in a proposed block.\ttxListSizeInBytes\t\tThe transaction list size in bytes.\nThe proposed block intrinsic validity function checks that all these conditions are met:\n(the block id is not too far ahead)\n(transaction list is not empty)\n(transaction list does not exceed the maximum size)\n(beneficiary is not zero)\n(block id is correct)\n(timestamp is correct)\n(mixHash is correct)\n(txListHash is not zero)\n(l1Height is correct)\n(l1Hash is correct)","transaction-list-intrinsic-validity-function#Transaction list intrinsic validity function":"The transaction list intrinsic validity function checks that the transaction list is valid and each transaction in the list is valid.A transaction list is valid if and only if:\nThe transaction list is well-formed RLP, with no additional trailing bytes (rule #1 in Ethereum yellow paper).\nThe transaction list is no larger than than .\nThe sum of all transactions' gas limit is no larger than the protocol constant .\nThe total number of transactions is no larger than the protocol constant .\n\nA transaction is valid if and only if:\nThe transaction is well-formed RLP, with no additional trailing bytes (rule #1 in the Ethereum yellow paper).\nThe transaction's signature is valid (rule #2 in Ethereum yellow paper).\nThe transaction's gas limit is no smaller than the intrinsic gas  (rule #5 in the Ethereum yellow paper).\n\nIf any of these fails, an empty block will be created on L2 (with only the anchor tx).","anchor-transaction#Anchor transaction":"The anchor transaction is a way for the protocol to make use of the programmability of the EVM (which we already need to be able to proof) to enforce certain protocol behavior. We can add additional tasks to anchor transactions to enrich Delite’s functionalities by writing standard smart contract code (instead of requiring more complicated changes to Delite’s ZK-EVM and node subsystems).The anchor transaction is required to be the first transaction in a Delite block (which is important to make the block deterministic). The anchor transaction is currently used as follows:\nPersisting l1Height , l1Hash , l1SignalRoot, and parentGasUsed (data inherited from L1) to the storage trie. These values can be used by bridges to validate cross-chain messages.\nComparing , the public input hash stored by the previous block, with KEC(i − 1, d, h[2..256]). The anchor transaction will throw an exception if such comparison fails. The protocol requires the anchor transaction to execute successfully and will not accept a proof for a block that fails to do so. Note that the genesis block has  ≡ KEC(0, d, [0, ..., 0]).\nPersisting a new public input hash  ≡ KEC(i, d, h[1..255]) to the storage trie for the next block to use. This allows transactions, in the current and all following blocks, to access these public input data with confidence as their values are now covered by ZK-EVM’s storage proof.\nWith anchoring, the block mapping function M (defined in the whitepaper) can be simplified to:"}},"/docs/guides":{"title":"Guides","data":{"":"You can leave feedback here and ask any questions on the Delite Discord!\n💻 Configure your wallet\n🎈 Receive tokens\n🌉 Use the bridge\n🔄 Swap tokens\n🌐 Run a node\n📤 Enable a proposer\n✅ Enable a prover\n🚀 Deploy a contract\n📜 Verify a contract\n🛠️ Build a dapp"}},"/docs/guides/build-a-dapp":{"title":"Build a dapp","data":{"":"","overview#Overview":"This guide will help you build a dapp on Delite in one click!","prerequisites#Prerequisites":"A curiosity to learn and build 🙃.","steps#Steps":"Visit the dapp-slaps starter template to create an Ethereum dapp in one click."}},"/docs/concepts/taiko-nodes":{"title":"Taiko Nodes","data":{"":"","overview#Overview":"Delite nodes are minimally modified Ethereum execution clients that consist of two parts:\ndelite-geth\ndelite-client\n\nYou can think of it like an Ethereum mainnet node, except replacing the consensus client with delite-client. delite-client then drives delite-geth over the Engine API. This is a modular design that allows easily plugging in other execution clients.","delite-geth#delite-geth":"The delite-geth software is a fork of go-ethereum with some changes made according to the Delite protocol.Like Ethereum mainnet execution engines, delite-geth listens to new L2 transactions broadcasted in the L2 network, executes them in the EVM, and holds the latest state and database of all current L2 data.You can see all the changes made in the the delite-geth fork at geth.delite.xyz!","delite-client#delite-client":"The delite-client software replaces the consensus client piece of an Ethereum mainnet node. It connects to delite-geth, and the compiled binary includes three sub-commands:","driver#driver":"The driver serves as an L2 consensus client. It listens for new L2 blocks from the DeliteL1 protocol contract, then directs the connected L2 execution engine to insert them or reorganize its local chain through the Engine API.","proposer#proposer":"The proposer fetches pending transactions from the L2 execution engine's mempool intervally pool, then tries to propose them to the DeliteL1 protocol contract.","prover#prover":"The prover requests validity proofs from the ZK-EVM and sends transactions to prove the proposed blocks are valid or invalid.","chain-synchronization-process#Chain synchronization process":"The Delite protocol allows a block's timestamp to be equal to its parent block's timestamp, which differs from the original Ethereum protocol. So it's fine that there are two DeliteL1.proposeBlock transactions included in one L1 block.\nDelite client's driver informs the L2 execution engine about Delite protocol contract's latest verified L2 head and tries to let it catch up with the latest verified L2 block through P2P at first.The driver monitors the execution engine's sync progress: If it's unable to make any new sync progress in a period of time, the driver switches to inserting the verified blocks into its local chain through the Engine API one by one.After the L2 execution engine catches up with the latest verified L2 head, the driver subscribes to DeliteL1.BlockProposed events. When a new pending block is proposed, the driver:\nGets the corresponding DeliteL1.proposeBlock L1 transaction.\nDecodes the txList and block metadata from the transaction's calldata.\nChecks whether the txList is valid based on the rules defined in the Delite protocol.\n\nIf the txList is valid, the driver:\nAssembles a deterministic DeliteL2.anchor transaction based on the rules defined in the protocol and puts it as the first transaction in the proposed txList.\nUses this txList and the decoded block metadata to assemble a deterministic L2 block.\nDirects the L2 execution engine to insert this assembled block and sets it as the current canonical chain's head via the Engine API.\n\nIf the txList is invalid, the driver:\nAssembles an empty L2 block with only the anchor transaction.\n\n\nRead more about block metadata here or see 5.2.2 Block Metadata in the whitepaper.Read more about txList validation rules here or see 5.3.1 Validation in the whitepaper.Read more about the DeliteL2.anchor transaction and proposed block's determination here or see 5.4.1 Construction of Anchor Transactions in the whitepaper.","proposing-process-in-depth#Proposing process (in depth)":"To propose a block, the proposer:\nFetches the pending transactions from the L2 execution engine through the txpool_content RPC method.\nIf there are too many pending transactions in the L2 execution engine, splits them into several smaller txLists. This is because the Delite protocol restricts the max size of each proposed txList.\nProposes all splitted txLists by sending DeliteL1.proposeBlock transactions.","proving-process-in-depth#Proving process (in depth)":"When a new block is proposed, the prover:\nGets the DeliteL1.proposeBlock L1 transaction calldata, decodes it, and validates the txList, just like what the driver software does.\nWaits until the corresponding block is inserted by the L2 execution engine's driver software.\nGenerates a validity proof for that block asynchronously.\n\nIf the proposed block has a valid or invalid txList, the prover:\nGenerates a Merkle proof of the block's DeliteL2.anchor transaction to prove its existence in the block.txRoot's MPT and this transaction receipt's Merkle proof in the block.receiptRoot's MPT from the L2 execution engine.\nSubmits the DeliteL2.anchor transaction's RLP encoded bytes, its receipt's RLP encoded bytes, the generated Merkle proofs, and a validity proof to prove this block valid by sending a DeliteL1.proveBlock transaction (the block is valid even for an invalid txList because we prove the invalid txList maps to an empty block with only the anchor transaction).\n\n\nRead more about why we need these Merkle proofs when proving in 5.5 Proving Blocks in the whitepaper."}},"/docs/concepts/proving":{"title":"Proving Delite blocks","data":{"":"","overview#Overview":"The purpose of proving blocks is to give certainty to bridges about the execution that happened in the rollup. To rely on some state that happened inside of the rollup, a bridge will want a proof that everything was done correctly. On Delite you can run a node as a prover and prove blocks, permissionlessly. This means that you can examine the proposed blocks on the DeliteL1 contract, and generate proofs for them. Currently, any prover can create proofs for proposed blocks. This means that the number of \"fork choices\" has no upper bound, because we don't know what is the correct state transition yet. Only first prover with a valid proof of the correct fork choice (state transition) will receive the reward of TTKO.","verified-blocks-and-parallel-proving#Verified blocks and parallel proving":"There are three states that a block can be in on Delite:\nProposed\nProved\nVerified\n\nWe already know what a proposed block is (must pass at least the block-level intrinsic validity tests to be accepted by the DeliteL1 contract). Next, a proposed block can be valid or invalid, depending on whether it passes the transaction list intrinsic validity test. A block is invalid if it fails the transaction list intrinsic validity test, and this block is not created on Delite.Now, a block can be proved, but also further \"verified\". What's the difference? A block is proved if it has a valid proof which proves a state transition from one state (parent block) to another (current block). However, blocks are proven in parallel by the decentralized provers. So while a block can prove a parent block transitions to the current block, we don't know if the parent block itself has been proven. As you can see, for a block to be \"verified\", it needs to prove the valid state transition to the current block, but the parent also need to be verified. We assume that the genesis block (which has no parent), is verified. So all the children blocks from genesis to the current block need to have proofs of their state transition for the current block to be \"verified\".For the visual learners here is a visualization of the three stages (proposed -> proved -> verified)Proposed:\n\n\n\nProved:\n\n\n\nVerified:","types-of-provers#Types of provers":"","community-prover#Community prover":"Currently, you only need a single proof from the any prover to verify a block.","oracle-prover#Oracle prover":"The oracle prover is a prover from a unique address (our own address) that is able to override the community prover. This is a safety mechanism we have in place while the ZK-EVM is still in development and in case an invalid block was marked as verified from a community proof.","system-proof#System proof":"A system proof is a fake proof that is generated by the system to mark a block as verified. We only require a real proof to be generated every N blocks. Otherwise, we accept a fake, system proof, and mark the block as verified. This is a temporary testnet feature to reduce the cost for community provers.","the-proof-cooldown-period#The proof cooldown period":"We have a proof cooldown period which is an interval of time we set after fully verifying a block. The reason we do that is to allow for a fault proof to come in, once we have a multi-prover system set in place.","prover-dynamics#Prover dynamics":"","how-the-proof-reward-is-determined#How the proof reward is determined":"A proof reward in TTKO is rewarded for successfully proving a block. This reward is dependent on the proofTimeTarget. You can see the current proof reward by calling getProofReward on the DeliteL1 contract.So that we don't grow a long list of unverified blocks for too long, we want to target proofs coming in at a certain rate. So we set a target proof time. If it has taken a long time since the last verified block, the proof reward increases to incentivize provers to generate a proof.Conversely, if everyone is submitting proofs quickly, then the proof reward decreases towards zero. This means that as a prover, you should query getProofReward on the DeliteL1 contract to determine if it is profitable to generate a proof. If you submit proofs as quickly as possible, then the proof reward will trend towards zero.","default-in-simple-delite-node#Default in simple-delite-node":"The simple-delite-node will come pre-configured to not submit proofs as quickly as possible, by querying getProofReward. This hopefully means that most nodes in the network are acting in the group interest, by responsibly not submitting the proof as quickly as possible. However, because the first prover will win the reward, and because the project is open source, anybody can modify the delite-client and act rationally to submit a proof slightly earlier than the default set in simple-delite-node. As you can see, it causes somewhat of a prisoner's dilemma.","proof-skip#Proof skip":"We have a realProofSkipSize set here so that a real proof is only needed every N blocks for the testnet.","your-role-as-a-prover#Your role as a prover":"We are describing this dynamic so you can be informed when you run a prover. It's very possible that without the correct strategy, you will not be profitable as a prover. You are naturally competing in an open space where others could have more efficient hardware and generate a proof in a short amount of time that you cannot compete against."}},"/docs/guides/enable-a-prover":{"title":"Enable a prover","data":{"":"Only the first prover can earn the TTKO reward, and others will be rejected by the protocol smart contract. This means the fastest prover will be able to prove the block and earn the reward, if you have just the minimum hardware outlined in the prerequisited below, running a single prover, it's unlikely you will be able to prove any blocks (because you will be competing against other high-performance provers).Meaning, if you do not have a powerful prover, the primary purpose of running a prover is to help test out and provide community feedback on running the node software. Keep in mind this will have a cost in electricity on your computer, and if you are not proving blocks, it's unlikely you will receive a reward to offset that electricity cost.Please see How the proof reward is determined for more details.","overview#Overview":"This guide will help you enable your Delite node as a prover.","prerequisites#Prerequisites":"You have already setup a node (see: Run a node)\nMust have some ETH on Sepolia (see: Receive tokens).\nShould have at least 8/16 core CPU and 32GB of RAM. (note: see warning above)","steps#Steps":"","open-env-file-in-simple-delite-node#Open .env file in simple-delite-node":"Open the .env file in the simple-delite-node directory.","set-environment-variables-to-enable-prover#Set environment variables to enable prover":"Set the following environment variables to enable your node as a prover:\nSet ENABLE_PROVER to true (replacing the default false with true).\nSet L1_PROVER_PRIVATE_KEY to that of your wallet's private key; it will need some ETH on Sepolia to prove blocks (if using MetaMask, follow these directions to retrieve the private key).","verify-prover-logs#Verify prover logs":"Verify you have some prover logs:\n💰 Your block proof was accepted means you are the first prover and receive the reward.\n✅ Valid block proven just means a proposed block was successfully proved on DeliteL1 (by anyone).\n\nIf you are running a node in the background, you can view the logs with docker compose logs -f.","troubleshooting#Troubleshooting":"Consult Run a node - Troubleshooting for common issues."}},"/docs/guides/configure-your-wallet":{"title":"Configure your wallet","data":{"":"","overview#Overview":"This guide help you connect your wallet to Delite (Alpha-3 testnet). There are two networks to configure your wallet with: Ethereum (Sepolia testnet) and Delite (Alpha-3 testnet).","prerequisites#Prerequisites":"You have a wallet installed and ready to use. Some examples are MetaMask and Frame. Please use a hot wallet (not a hardware wallet) for this guide, preferably a throwaway wallet.","steps#Steps":"","visit-chainlist#Visit chainlist":"Visit https://chainlist.org/ and check the box for \"Include Testnets\".","add-the-sepolia-testnet#Add the Sepolia testnet":"Search for \"Sepolia\", and click the \"Add Chain\" button.","add-the-delite-testnet#Add the Delite testnet":"Search for \"Delite\", and click the \"Add Chain\" button for Delite (Alpha-3 testnet).","add-tokens-to-your-wallet#Add tokens to your wallet":"Use your wallet (e.g., Metamask) to import the tokens with this configuration (HORSE, BLL, and TTKO).","troubleshooting#Troubleshooting":"","the-add-chain-buttons-did-not-work#The add chain buttons did not work":"Try to manually add the network to your wallet using the RPC configuration."}},"/docs/guides/deploy-a-contract":{"title":"Deploy a contract","data":{"":"","overview#Overview":"This guide will help you deploy a smart contract to Delite using Foundry or Hardhat.","prerequisites#Prerequisites":"You have Foundry or Hardhat installed.\nYou have testnet ETH on Delite (to pay the transaction fee for deploying the contract).\nYou can request Sepolia ETH from the faucet and then use the bridge to send the testnet ETH to Delite.\n\n\nYou have the private key to the account with testnet ETH on Delite.","additional-remix-prerequisites#Additional Remix prerequisites":"You have configured your wallet to connect to Delite.","steps#Steps":"","create-a-project-with-foundry#Create a project with Foundry":"forge init hello_foundry && cd hello_foundry","deploy-your-contract#Deploy your contract":"Deploy the contract located at src/Counter.sol. Replace YOUR_PRIVATE_KEY below with your private key which has some testnet ETH on Delite.\nUse a throwaway wallet to be safe. Don't reveal the private key of a wallet with significant value!\n\nforge create --rpc-url https://rpc.test.delite.xyz --private-key YOUR_PRIVATE_KEY src/Counter.sol:Counter","view-your-contract#View your contract":"Paste the address from the output into the Delite block explorer and verify that the contract was deployed.","create-a-project-with-hardhat#Create a project with Hardhat":"npx hardhat","add-delite-to-your-hardhat-config#Add Delite to your Hardhat config":"For the accounts array, you will need to enter the private key of the account you are deploying the contract with. It is not recommended to hardcode the private key like this (an environment variable would be better, but is still risky).Use a throwaway wallet to be safe. Don't reveal the private key of a wallet with significant value!\n\nimport { HardhatUserConfig } from \"hardhat/config\";\nimport \"@nomicfoundation/hardhat-toolbox\";\n\nconst config: HardhatUserConfig = {\nsolidity: \"0.8.18\",\nnetworks: {\ndelite: {\nurl: \"http://rpc.test.delite.xyz\",\naccounts: [\n\"0xf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897\",\n],\n},\n},\n};\n\nexport default config;","deploy-your-contract-on-delite#Deploy your contract on Delite":"npx hardhat run --network delite scripts/deploy.ts","view-your-contract-1#View your contract":"Paste the address from the output into the Delite block explorer and verify that the contract was deployed.","visit-remix-and-connect-your-wallet-to-delite#Visit Remix and connect your wallet to Delite":"Visit remix.ethereum.org and connect your wallet to Delite.","select-a-smart-contract#Select a smart contract":"","compile-your-smart-contract#Compile your smart contract":"","deploy-your-smart-contract#Deploy your smart contract":""}},"/docs/guides/swap-tokens":{"title":"Swap Tokens","data":{"":"","overview#Overview":"This guide will help you interact with Swap, which is a fork of Uniswap v2 that Delite has deployed only for testing purposes.","prerequisites#Prerequisites":"You must have some tokens (at least ETH) on Delite (Alpha-3 testnet). You can receive some ETH, HORSE, and BLL from the faucets and then bridge them to Delite.","steps#Steps":"","navigate-to-swap#Navigate to Swap":"Navigate to https://swap.test.delite.xyz.","connect-to-the-delite-testnet#Connect to the Delite testnet":"","choose-tokens-to-swap#Choose tokens to swap":"If you do not see the tokens, you might be prompted to add the testnet tokens (see below)","input-swap-amount#Input swap amount":"","one-time-approve-the-token-to-swap#[One-time] Approve the token to swap":"","swap-tokens#Swap tokens":"Here we swap BLL tokens for HORSE tokens.\nTry with small amounts as there might not be sufficient liquidity.","view-transaction-on-blockscout#View Transaction on blockscout":"","troubleshooting#Troubleshooting":"","token-list-does-not-show-up#Token list does not show up":""}},"/docs/guides/receive-tokens":{"title":"Receive tokens","data":{"":"","overview#Overview":"This guide will help you receive testnet tokens from the faucet(s).","prerequisites#Prerequisites":"You have an Ethereum wallet address to accept the testnet tokens.","steps#Steps":"","receive-sepolia-eth#Receive Sepolia ETH":"Visit one of the faucets to receive ETH on Sepolia:\nhttps://sepolia-faucet.pk910.de\nhttps://faucet-sepolia.rockx.com\nhttps://sepoliafaucet.com\nhttps://www.infura.io/faucet/sepolia","receive-horse#Receive HORSE":"Navigate to the bridge, select HORSE from the dropdown, and click \"Faucet\".","receive-bll#Receive BLL":"Repeat the previous step for receiving HORSE, except select \"BLL\" from the dropdown.","receive-ttko#Receive TTKO":"TTKO will not be distributed immediately at the launch of alpha-3, but will be distributed shortly after.\nComing soon 👀"}},"/docs/guides/enable-a-proposer":{"title":"Enable a proposer","data":{"":"TTKO will not be distributed immediately at the launch of alpha-3, but will be distributed shortly after.","overview#Overview":"This guide will help you enable your Delite node as a proposer.","prerequisites#Prerequisites":"You have already setup a node (see: Run a node)\nMust have a balance of ETH and TTKO on Sepolia (see: Receive tokens).","steps#Steps":"","visit-the-delitel1-contract-on-sepolia-etherscan#Visit the DeliteL1 contract on Sepolia Etherscan":"Navigate to the DeliteL1 contract on Sepolia.Click Connect to Web3 and connect your wallet.","enter-deposit-amount#Enter deposit amount":"Click depositDeliteToken and enter the amount of TTKO you would like to deposit followed by 8 zeroes.\nMake sure to click the plus sign and add 10^8 decimals, or add 8 zeroes manually.\nFor example if you want to deposit 69 TTKO, you would enter 6900000000.","deposit-your-ttko#Deposit your TTKO":"Click Write and confirm the transaction in your wallet.","open-env-file-in-simple-delite-node#Open .env file in simple-delite-node":"Open the .env file in the simple-delite-node directory.","set-environment-variables-to-enable-a-proposer#Set environment variables to enable a proposer":"Set the following environment variables to enable your node as a proposer:\nSet ENABLE_PROPOSER to true (replacing the default false with true).\nSet L1_PROPOSER_PRIVATE_KEY to that of your wallet's private key; it will need some TTKO on Sepolia to propose blocks (if using MetaMask, follow these directions to retrieve the private key).\nSet L2_SUGGESTED_FEE_RECIPIENT to the recipient of L2 ETH rewards.","verify-proposer-logs#Verify proposer logs":"You should see a log if you have proposed a block: 📝 Propose transactions succeeded.If you are running a node in the background, you can view the logs with docker compose logs -f."}},"/docs":{"title":"Index","data":{"":"","welcome-to-delite-#Welcome to Delite 🥁":"Delite is a decentralized, Ethereum-equivalent ZK-Rollup (Type 1 ZK-EVM). We're working on the full Ethereum ZK-EVM circuits as part of a community effort led by the Ethereum Foundation's Privacy and Scaling Explorations (PSE) team.Check out the Delite roadmap to see where we're going!","get-started#Get started":"Check out the guides section get started with Delite on the testnet!","contribute-to-delite#Contribute to Delite":"Delite is an open-source, community-driven project that welcomes and values every and any contribution. That's including both technical and non-technical contributions.Take a look at the contributing page to get started as a contributor!","join-the-community#Join the community":"Delite has a vibrant, talented, and supportive community. Become part of the Delite community on:\nDiscord: Join our Discord server to ask questions, get technical support, and just have fun.\nTwitter: Follow us on Twitter to get the latest announcements, read insightful threads, and connect with peers.\nCommunity forum: Come to our community forum for more in-depth research, development, and other discussions.\n\nHope to see you soon! 🫶"}},"/docs/guides/run-a-node":{"title":"Run a node","data":{"":"","overview#Overview":"This guide will walk you through the process of operating a Delite node via simple-delite-node. You will be able to:\nRun a Delite node easily from the command line on Windows, Mac, and Linux.\nView a Grafana dashboard which displays the node's status.","prerequisites#Prerequisites":"Docker is installed and running.\nGit is installed.\nConsult the Geth minimum hardware requirements, with the exception of 1TB of free space (~50GB should be more than enough initially, but over time it could become insufficient as the chain grows).","steps#Steps":"","clone-simple-delite-node#Clone simple-delite-node":"git clone https://github.com/delitesystems/simple-delite-node.git\ncd simple-delite-node","configure-your-node-required#Configure your node (required)":"First, copy the .env.sample to a new file .env:\ncp .env.sample .env\nNext, open the .env file in your preferred text editor:\n\n\nnano .env\n\n\n\nvim .env\n\n\n\nnotepad .env\n\n\nFinally, set the following environment variables:\nL1_ENDPOINT_HTTP\nL1_ENDPOINT_WS\n\n\nYou can get a Sepolia L1 endpoint from a few places, but it must point to an archive node to access the state trie beyond the last 128 blocks.\nAlchemy and Infura are two popular RPC providers. Make sure you select the RPC as Sepolia testnet, and not Ethereum mainnet.","enable-your-node-as-a-proposer-optional#Enable your node as a proposer (optional)":"See enable a proposer for more information.","enable-your-node-as-a-prover-optional#Enable your node as a prover (optional)":"See enable a prover for more information.","start-a-node#Start a node":"If you ran a testnet node previously make sure to first run a docker compose down -v to remove the old volumes. Also, it may take some time to synchronize from the genesis block. You can monitor this progress through logs, or in the local grafana dashboard and see the latest L2 chain status in the Delite block explorer.\nMake sure Docker is running and then run the following command to start the node. If you want to run it in the background, please add the -d flag (docker compose up -d).\ndocker compose up\nTo run the node in the background (detached mode), use the -d flag:\ndocker compose up -d","stop-a-node#Stop a node":"This command shuts down the node, but will keep all volumes, so next time you restart the node, it won't need to synchronize from the genesis again.\ndocker compose down","remove-a-node#Remove a node":"These commands will completely remove the node by removing all volumes used by each container:\ndocker compose down -v\nrm -f .env","update-a-node#Update a node":"Update the simple-delite-node Docker images:\ndocker compose pull","view-the-nodes-logs#View the node's logs":"To view the Docker logs, the following commands can be ran:","view-all-logs#View all logs":"docker compose logs -f","view-the-proposer-images-logs#View the proposer image's logs":"docker compose logs -f delite_client_proposer","view-the-prover-images-logs#View the prover image's logs":"docker compose logs -f delite_client_prover_relayer","view-the-l2-execution-engine-logs#View the L2 execution engine logs":"docker compose logs -f l2_execution_engine","view-the-live-data-streams-of-your-running-containers#View the live data streams of your running containers":"This shows the CPU/MEM USAGE % and consumption of your machine's resources (add prefix \"docker stats -a\" to display all containers)\ndocker stats","view-the-nodes-status-dashboard#View the node's status dashboard":"A Grafana dashboard with a Prometheus datasource is also included to display the L2 execution engine's real time status.You can visit it at http://localhost:3000/d/L2ExecutionEngine/l2-execution-engine-overview.","troubleshooting#Troubleshooting":"","node-warning-logs#Node warning logs":"You can ignore any WARN logs.","node-error-logs#Node error logs":"","error-failed-to-insert-new-head-to-l2-execution-engine-missing-trie-node#error: \"failed to insert new head to L2 execution engine: missing trie node\"":"Make sure that your RPC is pointing to an Sepolia archive node, and not a full node.","error-l1_block_id#error: L1_BLOCK_ID":"The block that you want to prove has already been verified, you can ignore this.","error-l1_already_proven#error: L1_ALREADY_PROVEN":"This block has been proven by someone else, but its not verified yet, you can ignore it.","fatal-failed-to-register-the-ethereum-service-database-contains-incompatible-genesis#Fatal: Failed to register the Ethereum service: database contains incompatible genesis":"Try to remove the node with docker compose down -v and then try again.","unhandled-trie-error-missing-trie-node#Unhandled trie error: missing trie node":"You can ignore this error, it doesn't affect you and goes away after a while.","block-batch-iterator-callback-error-errorfailed-to-fetch-l2-parent-block-not-found#Block batch iterator callback error; error=\"failed to fetch L2 parent block: not found":"You can ignore this error.","error-starting--listen-tcp4-0000port-bind-address-already-in-use#Error starting ...: listen tcp4 0.0.0.0:{port} bind: address already in use":"The port is already in use by another service. You can either shut down the other program or change the port in the .env file.","error-parsing-http-403-response-body-invalid-character--looking-for-beginning-of-value#error parsing HTTP 403 response body: invalid character '<' looking for beginning of value":"Your IP address is being geo-blocked due to sanctions lists. If you're affected, try changing hosting locations or utilize a VPN to change your IP address.","error-the-compose-file-docker-composeyml-is-invalid-because-unsupported-config-option-for-some_service-pull_policy#ERROR: The Compose file './docker-compose.yml' is invalid because: Unsupported config option for some_service 'pull_policy'":"Your docker installation is out of date. You need to update your docker compose installation: https://docs.docker.com/compose/install/.","daemon-docker-is-not-running--cannot-connect-to-the-docker-daemon#daemon docker is not running  Cannot connect to the Docker daemon":"Need to start the Docker before running the commands.","database-contains-incompatible-genesis#database contains incompatible genesis":"If you ran an alpha-1 testnet node make sure to first run a docker compose down -v to remove the old volumes.","bind-for-0000port-failed-port-already-allocated#Bind for 0.0.0.0:port failed: port already allocated":"This error just means that the port delite-node is trying to allocate is already being used by either some other node you're running\nor by a left-over container of delite node if you did not close down the node correctly, you can try running docker compose down in the simple-delite-node folder and start it again using docker compose up -d\nor edit the .env and replace the problematic port with a different one.","failed-to-fetch-l1origin-from-l2-execution-engine-brbr-errnot-found#Failed to fetch L1Origin from L2 execution engine <br></br> err=\"not found\"":"This seems to be a common issue if you're using Alchemy endpoints, switching to Infura should fix this issue.","no-configuration-file-provided-not-found#no configuration file provided: not found":"You are in the wrong directory, cd simple-delite-node and run the command again.","unknown-shorthand-flag-d-in--d#unknown shorthand flag: 'd' in -d":"You are using v1 of docker-compose, use the command: docker-compose up -d instead of docker compose up -d, I highly recommend that you upgrade to the v2 of docker compose plugin Installation Guide","docker-compose-is-not-a-docker-command#docker: 'compose' is not a docker command":"You are missing the docker compose plugin Installation Guide","delite_client_prover_relayer-not-printing-any-logs#delite_client_prover_relayer not printing any logs":"There could be several reasons, you can check the logs docker compose logs -f to make sure there are no errors but one of the most common cause for this is a typo in the .env file\nENABLE_PROVER=True/TRUE when setting this to true true has to be in all lowercase or the script to start relayer won't run.","simple-delite-node-delite_client_prover_relayer-1---binsh-scriptstart-prover-relayersh-not-found#simple-delite-node-delite_client_prover_relayer-1  | /bin/sh: /script/start-prover-relayer.sh: not found":"This issue occurs on windows because of the Control Characters in this case the Line Endings, a quick fix would be to delete the node folder, run this git config --global core.autocrlf false in the shell, then clone the repo again."}},"/docs/guides/use-the-bridge":{"title":"Use the bridge","data":{"":"The BLL token is expected to fail about 50% of the time when bridging--this is done intentionally to test error handling.","overview#Overview":"This guide will help you use the bridge to send tokens between Sepolia and Delite (Alpha-3 testnet). You can read more about how bridging works here.","prerequisites#Prerequisites":"A wallet with some testnet ETH on Sepolia and/or Delite (you can receive tokens here).","steps#Steps":"","visit-the-bridge#Visit the bridge":"Visit the bridge and the UI should be intuitive.","bridge-tokens-from-sepolia-to-delite#Bridge tokens from Sepolia to Delite":"Try bridging ETH, HORSE, and/or BLL from Sepolia to Delite. You can also try manually claiming the transfer yourself by clicking the \"Claim\" button under the \"Transactions\" tab.","bridge-tokens-from-delite-to-sepolia#Bridge tokens from Delite to Sepolia":"Try bridging ETH, HORSE, and/or BLL from Delite to Sepolia. You can also try manually claiming the transfer yourself by clicking the \"Claim\" button under the \"Transactions\" tab."}},"/docs/reference/contract-addresses":{"title":"Contract addresses","data":{"":"","protocol-contracts#Protocol contracts":"Sepolia\nContract name\tContract address\tAddressManager\t0xB566C97d37662f8a5843D523bE7806e04b02D99d\tBridge\t0x7D992599E1B8b4508Ba6E2Ba97893b4C36C23A28\tSignalService\t0x23baAc3892a823e9E59B85d6c90068474fe60086\tDeliteL1\t0x6375394335f34848b850114b66A49D6F47f2cdA8\tTokenVault\t0xD70506580B5F65e68ed0dbA7B4Ae507641C48197\nDelite\nContract name\tContract address\tBridge\t0x1000777700000000000000000000000000000004\tEtherVault\t0x0000777700000000000000000000000000000003\tSignalService\t0x1000777700000000000000000000000000000007\tDeliteL2\t0x0000777700000000000000000000000000000001\tTokenVault\t0x0000777700000000000000000000000000000002","erc-20-token-contracts#ERC-20 token contracts":"Sepolia\nName\tSymbol\tContract address\tBull Token\tBLL\t0x39e12053803898211F21047D56017986E0f070c1\tHorse Token\tHORSE\t0x958b482c4E9479a600bFFfDDfe94D974951Ca3c7\tTest Delite Token\tTTKO\t0xE52952B8063d0AE6Bd35E894866d8148976ce645\nDelite\nName\tSymbol\tContract address\tBull Token\tBLL\t0x6302744962a0578E814c675B40909e64D9966B0d\tHorse Token\tHORSE\t0xa4505BB7AA37c2B68CfBC92105D10100220748EB\tTest Delite Token\tTTKO\t0x7b1a3117B2b9BE3a3C31e5a097c7F890199666aC","delites-node-addresses#Delite's node addresses":"Name\tAddress\tDelite's personal proposer\t0xE09e4fF4353fbf984F99fa824524277F704e7475\tDelite's relayer\t0xe07b3455f382E6912558f613e072c1a46964eDBb\tOracle prover\t0x6798639591530FbBAfd12c2826422B58bD2c5219\tSystem prover 1\t0x89697A45BA1FEFbc575BdcA6e0C50D5112A5a766\tSystem prover 2\t0xC9060A394ab1986D29aaB985ba41B2E516325900"}},"/docs/reference/contract-documentation/L1/TaikoConfig":{"title":"DeliteConfig","data":{"":"","deliteconfig#DeliteConfig":"","getconfig#getConfig":"function getConfig() internal pure returns (struct DeliteData.Config)"}},"/docs/guides/verify-a-contract":{"title":"Verify a contract","data":{"":"","overview#Overview":"This guide will help get your contract verified on Delite!","prerequisites#Prerequisites":"You have a contract deployed on Delite and the source code available.","steps#Steps":"","add-etherscan-config-to-hardhat-config#Add Etherscan config to Hardhat config":"Even though the config is called etherscan, it is used for all explorers that support the Etherscan API (including Blockscout). The API key is set to a dummy value 42069 because it is not used for Blockscout verification.\n\nimport { HardhatUserConfig } from \"hardhat/config\";\nimport \"@nomicfoundation/hardhat-toolbox\";\n\nconst config: HardhatUserConfig = {\nsolidity: \"0.8.18\",\nnetworks: {\ndelite: {\nurl: \"https://rpc.test.delite.xyz\",\naccounts: [\n\"0xf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897\",\n],\n},\n},\netherscan: {\napiKey: {\ndelite: \"42069\",\n},\ncustomChains: [\n{\nnetwork: \"delite\",\nchainId: 167005,\nurls: {\napiURL: \"https://explorer.test.delite.xyz/api\",\nbrowserURL: \"https://explorer.test.delite.xyz\",\n},\n},\n],\n},\n};\n\nexport default config;","run-the-verify-task#Run the verify task":"Run the verify task, but replace DEPLOYED_CONTRACT_ADDRESS and \"Constructor argument 1\" with the address of your deployed contract and the constructor arguments you used when deploying the contract.\nnpx hardhat verify --network delite DEPLOYED_CONTRACT_ADDRESS \"Constructor argument 1\"","view-your-verified-contract-on-blockscout#View your verified contract on Blockscout":"Check the Delite block explorer link from the output to see your contract was verified.","follow-blockscouts-official-guide#Follow Blockscout's official guide":"Follow Blockscout's official guide to verify your contract on Delite's blockscout explorers.\n\n\n\nFoundry's verify-contract command is currently broken with Blockscout (see why here). Please check the Hardhat or Blockscout steps to verify your contract."}},"/docs/reference/contract-documentation/L1/TaikoData":{"title":"DeliteData","data":{"":"","delitedata#DeliteData":"","config#Config":"struct Config {\nuint256 chainId;\nuint256 maxNumProposedBlocks;\nuint256 ringBufferSize;\nuint256 maxVerificationsPerTx;\nuint64 blockMaxGasLimit;\nuint64 maxTransactionsPerBlock;\nuint64 maxBytesPerTxList;\nuint256 txListCacheExpiry;\nuint256 proofCooldownPeriod;\nuint256 systemProofCooldownPeriod;\nuint256 realProofSkipSize;\nuint256 ethDepositGas;\nuint256 ethDepositMaxFee;\nuint64 minEthDepositsPerBlock;\nuint64 maxEthDepositsPerBlock;\nuint96 maxEthDepositAmount;\nuint96 minEthDepositAmount;\nbool relaySignalRoot;\n}","statevariables#StateVariables":"struct StateVariables {\nuint64 blockFee;\nuint64 genesisHeight;\nuint64 genesisTimestamp;\nuint64 numBlocks;\nuint64 lastVerifiedBlockId;\nuint64 nextEthDepositToProcess;\nuint64 numEthDeposits;\n}","blockmetadatainput#BlockMetadataInput":"struct BlockMetadataInput {\nbytes32 txListHash;\naddress beneficiary;\nuint32 gasLimit;\nuint24 txListByteStart;\nuint24 txListByteEnd;\nuint8 cacheTxListInfo;\n}","blockmetadata#BlockMetadata":"struct BlockMetadata {\nuint64 id;\nuint64 timestamp;\nuint64 l1Height;\nbytes32 l1Hash;\nbytes32 mixHash;\nbytes32 txListHash;\nuint24 txListByteStart;\nuint24 txListByteEnd;\nuint32 gasLimit;\naddress beneficiary;\naddress treasury;\nstruct DeliteData.EthDeposit[] depositsProcessed;\n}","blockevidence#BlockEvidence":"struct BlockEvidence {\nbytes32 metaHash;\nbytes32 parentHash;\nbytes32 blockHash;\nbytes32 signalRoot;\nbytes32 graffiti;\naddress prover;\nuint32 parentGasUsed;\nuint32 gasUsed;\nuint16 verifierId;\nbytes proof;\n}","forkchoice#ForkChoice":"struct ForkChoice {\nbytes32 key;\nbytes32 blockHash;\nbytes32 signalRoot;\nuint64 provenAt;\naddress prover;\nuint32 gasUsed;\n}","block#Block":"struct Block {\nmapping(uint256 => struct DeliteData.ForkChoice) forkChoices;\nuint64 blockId;\nuint64 proposedAt;\nuint24 nextForkChoiceId;\nuint24 verifiedForkChoiceId;\nbytes32 metaHash;\naddress proposer;\n}","txlistinfo#TxListInfo":"struct TxListInfo {\nuint64 validSince;\nuint24 size;\n}","ethdeposit#EthDeposit":"struct EthDeposit {\naddress recipient;\nuint96 amount;\nuint64 id;\n}","state#State":"struct State {\nmapping(uint256 => struct DeliteData.Block) blocks;\nmapping(uint256 => mapping(bytes32 => mapping(uint32 => uint256))) forkChoiceIds;\nmapping(address => uint256) deliteTokenBalances;\nmapping(bytes32 => struct DeliteData.TxListInfo) txListInfo;\nstruct DeliteData.EthDeposit[] ethDeposits;\nuint64 genesisHeight;\nuint64 genesisTimestamp;\nuint16 __reserved70;\nuint48 __reserved71;\nuint64 __reserved72;\nuint64 __reserved80;\nuint64 __reserved81;\nuint64 numBlocks;\nuint64 nextEthDepositToProcess;\nuint64 blockFee;\nuint64 __reserved90;\nuint64 lastVerifiedBlockId;\nuint64 __reserved91;\nuint256[42] __gap;\n}"}},"/docs/reference/contract-documentation/L1/TaikoErrors":{"title":"DeliteErrors","data":{"":"","deliteerrors#DeliteErrors":"","l1_already_proven#L1_ALREADY_PROVEN":"error L1_ALREADY_PROVEN()","l1_block_id#L1_BLOCK_ID":"error L1_BLOCK_ID()","l1_evidence_mismatch#L1_EVIDENCE_MISMATCH":"error L1_EVIDENCE_MISMATCH(bytes32 expected, bytes32 actual)","l1_fork_choice_not_found#L1_FORK_CHOICE_NOT_FOUND":"error L1_FORK_CHOICE_NOT_FOUND()","l1_invalid_config#L1_INVALID_CONFIG":"error L1_INVALID_CONFIG()","l1_invalid_eth_deposit#L1_INVALID_ETH_DEPOSIT":"error L1_INVALID_ETH_DEPOSIT()","l1_invalid_evidence#L1_INVALID_EVIDENCE":"error L1_INVALID_EVIDENCE()","l1_invalid_metadata#L1_INVALID_METADATA":"error L1_INVALID_METADATA()","l1_invalid_param#L1_INVALID_PARAM":"error L1_INVALID_PARAM()","l1_invalid_proof#L1_INVALID_PROOF":"error L1_INVALID_PROOF()","l1_invalid_proof_overwrite#L1_INVALID_PROOF_OVERWRITE":"error L1_INVALID_PROOF_OVERWRITE()","l1_not_special_prover#L1_NOT_SPECIAL_PROVER":"error L1_NOT_SPECIAL_PROVER()","l1_oracle_prover_disabled#L1_ORACLE_PROVER_DISABLED":"error L1_ORACLE_PROVER_DISABLED()","l1_same_proof#L1_SAME_PROOF":"error L1_SAME_PROOF()","l1_system_prover_disabled#L1_SYSTEM_PROVER_DISABLED":"error L1_SYSTEM_PROVER_DISABLED()","l1_system_prover_prohibited#L1_SYSTEM_PROVER_PROHIBITED":"error L1_SYSTEM_PROVER_PROHIBITED()","l1_too_many_blocks#L1_TOO_MANY_BLOCKS":"error L1_TOO_MANY_BLOCKS()","l1_tx_list_not_exist#L1_TX_LIST_NOT_EXIST":"error L1_TX_LIST_NOT_EXIST()","l1_tx_list_hash#L1_TX_LIST_HASH":"error L1_TX_LIST_HASH()","l1_tx_list_range#L1_TX_LIST_RANGE":"error L1_TX_LIST_RANGE()","l1_tx_list#L1_TX_LIST":"error L1_TX_LIST()"}},"/docs/reference/contract-documentation/L2/LibL2Consts":{"title":"LibL2Consts","data":{"":"","libl2consts#LibL2Consts":"","anchor_gas_cost#ANCHOR_GAS_COST":"uint64 ANCHOR_GAS_COST"}},"/docs/reference/contract-documentation/L2/TaikoL2":{"title":"DeliteL2","data":{"":"","delitel2#DeliteL2":"","verifiedblock#VerifiedBlock":"struct VerifiedBlock {\nbytes32 blockHash;\nbytes32 signalRoot;\n}","eip1559params#EIP1559Params":"struct EIP1559Params {\nuint64 basefee;\nuint64 gasIssuedPerSecond;\nuint64 gasExcessMax;\nuint64 gasTarget;\nuint64 ratio2x1x;\n}","eip1559config#EIP1559Config":"struct EIP1559Config {\nuint128 yscale;\nuint64 xscale;\nuint64 gasIssuedPerSecond;\n}","publicinputhash#publicInputHash":"bytes32 publicInputHash","parenttimestamp#parentTimestamp":"uint64 parentTimestamp","latestsyncedl1height#latestSyncedL1Height":"uint64 latestSyncedL1Height","gasexcess#gasExcess":"uint64 gasExcess","anchored#Anchored":"event Anchored(uint64 number, uint64 basefee, uint64 gaslimit, uint64 timestamp, bytes32 parentHash, uint256 prevrandao, address coinbase, uint32 chainid)","l2_basefee_mismatch#L2_BASEFEE_MISMATCH":"error L2_BASEFEE_MISMATCH(uint64 expected, uint64 actual)","l2_invalid_1559_params#L2_INVALID_1559_PARAMS":"error L2_INVALID_1559_PARAMS()","l2_invalid_chain_id#L2_INVALID_CHAIN_ID":"error L2_INVALID_CHAIN_ID()","l2_invalid_sender#L2_INVALID_SENDER":"error L2_INVALID_SENDER()","l2_public_input_hash_mismatch#L2_PUBLIC_INPUT_HASH_MISMATCH":"error L2_PUBLIC_INPUT_HASH_MISMATCH(bytes32 expected, bytes32 actual)","l2_too_late#L2_TOO_LATE":"error L2_TOO_LATE()","m1559_unexpected_change#M1559_UNEXPECTED_CHANGE":"error M1559_UNEXPECTED_CHANGE(uint64 expected, uint64 actual)","m1559_out_of_stock#M1559_OUT_OF_STOCK":"error M1559_OUT_OF_STOCK()","init#init":"function init(address _addressManager, struct DeliteL2.EIP1559Params _param1559) external","anchor#anchor":"function anchor(bytes32 l1Hash, bytes32 l1SignalRoot, uint64 l1Height, uint64 parentGasUsed) external\nPersist the latest L1 block height and hash to L2 for cross-layer\nmessage verification (eg. bridging). This function will also check\ncertain block-level global variables because they are not part of the\nTrie structure.A circuit will verify the integrity among:\nl1Hash, l1SignalRoot, and l1SignalServiceAddress\n(l1Hash and l1SignalServiceAddress) are both hashed into of the\nZKP's instance.\n\nThis transaction shall be the first transaction in every L2 block.","parameters#Parameters":"Name\tType\tDescription\tl1Hash\tbytes32\tThe latest L1 block hash when this block was proposed.\tl1SignalRoot\tbytes32\tThe latest value of the L1 \"signal service storage root\".\tl1Height\tuint64\tThe latest L1 block height when this block was proposed.\tparentGasUsed\tuint64\tthe gas used in the parent block.","getbasefee#getBasefee":"function getBasefee(uint32 timeSinceParent, uint64 gasLimit, uint64 parentGasUsed) public view returns (uint256 _basefee)","getcrosschainblockhash#getCrossChainBlockHash":"function getCrossChainBlockHash(uint256 number) public view returns (bytes32)\nReturns the cross-chain block hash at the given block number.","parameters-1#Parameters":"Name\tType\tDescription\tnumber\tuint256\tThe block number. Use 0 for the latest block.","return-values#Return Values":"Name\tType\tDescription\t[0]\tbytes32\tThe cross-chain block hash.","getcrosschainsignalroot#getCrossChainSignalRoot":"function getCrossChainSignalRoot(uint256 number) public view returns (bytes32)\nReturns the cross-chain signal service storage root at the given\nblock number.","parameters-2#Parameters":"Name\tType\tDescription\tnumber\tuint256\tThe block number. Use 0 for the latest block.","return-values-1#Return Values":"Name\tType\tDescription\t[0]\tbytes32\tThe cross-chain signal service storage root.","getblockhash#getBlockHash":"function getBlockHash(uint256 number) public view returns (bytes32)","geteip1559config#getEIP1559Config":"function getEIP1559Config() public view virtual returns (struct DeliteL2.EIP1559Config)\nOveride this funciton to return a constant EIP1559Config object","title-proxieddelitel2#title: ProxiedDeliteL2":"","proxieddelitel2#ProxiedDeliteL2":""}},"/docs/reference/contract-documentation/L1/TaikoL1":{"title":"DeliteL1","data":{"":"","delitel1#DeliteL1":"","state#state":"struct DeliteData.State state","receive#receive":"receive() external payable","init#init":"function init(address _addressManager, bytes32 _genesisBlockHash, uint64 _initBlockFee) external\nInitialize the rollup.","parameters#Parameters":"Name\tType\tDescription\t_addressManager\taddress\tThe AddressManager address.\t_genesisBlockHash\tbytes32\tThe block hash of the genesis block.\t_initBlockFee\tuint64\tInitial (reasonable) block fee value.","proposeblock#proposeBlock":"function proposeBlock(bytes input, bytes txList) external returns (struct DeliteData.BlockMetadata meta)\nPropose a Delite L2 block.","parameters-1#Parameters":"Name\tType\tDescription\tinput\tbytes\tAn abi-encoded BlockMetadataInput that the actual L2 block header must satisfy.\ttxList\tbytes\tA list of transactions in this block, encoded with RLP. Note, in the corresponding L2 block an anchor transaction will be the first transaction in the block -- if there are n transactions in txList, then there will be up to n + 1 transactions in the L2 block.","proveblock#proveBlock":"function proveBlock(uint256 blockId, bytes input) external\nProve a block with a zero-knowledge proof.","parameters-2#Parameters":"Name\tType\tDescription\tblockId\tuint256\tThe index of the block to prove. This is also used to select the right implementation version.\tinput\tbytes\tAn abi-encoded DeliteData.BlockEvidence object.","verifyblocks#verifyBlocks":"function verifyBlocks(uint256 maxBlocks) external\nVerify up to N blocks.","parameters-3#Parameters":"Name\tType\tDescription\tmaxBlocks\tuint256\tMax number of blocks to verify.","depositethertol2#depositEtherToL2":"function depositEtherToL2() public payable","getdelitetokenbalance#getDeliteTokenBalance":"function getDeliteTokenBalance(address addr) public view returns (uint256)","getblockfee#getBlockFee":"function getBlockFee() public view returns (uint64)","getblock#getBlock":"function getBlock(uint256 blockId) public view returns (bytes32 _metaHash, address _proposer, uint64 _proposedAt)","getforkchoice#getForkChoice":"function getForkChoice(uint256 blockId, bytes32 parentHash, uint32 parentGasUsed) public view returns (struct DeliteData.ForkChoice)","getcrosschainblockhash#getCrossChainBlockHash":"function getCrossChainBlockHash(uint256 blockId) public view returns (bytes32)","getcrosschainsignalroot#getCrossChainSignalRoot":"function getCrossChainSignalRoot(uint256 blockId) public view returns (bytes32)","getstatevariables#getStateVariables":"function getStateVariables() public view returns (struct DeliteData.StateVariables)","getconfig#getConfig":"function getConfig() public pure virtual returns (struct DeliteData.Config)","getverifiername#getVerifierName":"function getVerifierName(uint16 id) public pure returns (bytes32)","title-proxieddelitel1#title: ProxiedDeliteL1":"","proxieddelitel1#ProxiedDeliteL1":""}},"/docs/reference/contract-documentation/L2/TaikoL2Signer":{"title":"DeliteL2Signer","data":{"":"","delitel2signer#DeliteL2Signer":"","golden_touch_address#GOLDEN_TOUCH_ADDRESS":"address GOLDEN_TOUCH_ADDRESS","golden_touch_privatekey#GOLDEN_TOUCH_PRIVATEKEY":"uint256 GOLDEN_TOUCH_PRIVATEKEY","l2_invalid_golden_touch_k#L2_INVALID_GOLDEN_TOUCH_K":"error L2_INVALID_GOLDEN_TOUCH_K()","signanchor#signAnchor":"function signAnchor(bytes32 digest, uint8 k) public view returns (uint8 v, uint256 r, uint256 s)"}},"/docs/reference/contract-documentation/bridge/BridgedERC20":{"title":"BridgedERC20","data":{"":"","bridgederc20#BridgedERC20":"This contract is an upgradeable ERC20 contract that represents tokens bridged\nfrom another chain.","srctoken#srcToken":"address srcToken","srcchainid#srcChainId":"uint256 srcChainId","bridgemint#BridgeMint":"event BridgeMint(address account, uint256 amount)","bridgeburn#BridgeBurn":"event BridgeBurn(address account, uint256 amount)","init#init":"function init(address _addressManager, address _srcToken, uint256 _srcChainId, uint8 _decimals, string _symbol, string _name) external\nInitializes the contract.Different BridgedERC20 Contract to be deployed\nper unique _srcToken i.e. one for USDC, one for USDT etc.","parameters#Parameters":"Name\tType\tDescription\t_addressManager\taddress\tThe address manager.\t_srcToken\taddress\tThe source token address.\t_srcChainId\tuint256\tThe source chain ID.\t_decimals\tuint8\tThe number of decimal places of the source token.\t_symbol\tstring\tThe symbol of the token.\t_name\tstring\tThe name of the token.","bridgemintto#bridgeMintTo":"function bridgeMintTo(address account, uint256 amount) public\nMints tokens to an account.Only a TokenVault can call this function.","parameters-1#Parameters":"Name\tType\tDescription\taccount\taddress\tThe account to mint tokens to.\tamount\tuint256\tThe amount of tokens to mint.","bridgeburnfrom#bridgeBurnFrom":"function bridgeBurnFrom(address account, uint256 amount) public\nBurns tokens from an account.Only a TokenVault can call this function.","parameters-2#Parameters":"Name\tType\tDescription\taccount\taddress\tThe account to burn tokens from.\tamount\tuint256\tThe amount of tokens to burn.","transfer#transfer":"function transfer(address to, uint256 amount) public returns (bool)\nTransfers tokens from the caller to another account.Any address can call this. Caller must have at least 'amount' to\ncall this.","parameters-3#Parameters":"Name\tType\tDescription\tto\taddress\tThe account to transfer tokens to.\tamount\tuint256\tThe amount of tokens to transfer.","transferfrom#transferFrom":"function transferFrom(address from, address to, uint256 amount) public returns (bool)\nTransfers tokens from one account to another account.Any address can call this. Caller must have allowance of at least\n'amount' for 'from's tokens.","parameters-4#Parameters":"Name\tType\tDescription\tfrom\taddress\tThe account to transfer tokens from.\tto\taddress\tThe account to transfer tokens to.\tamount\tuint256\tThe amount of tokens to transfer.","decimals#decimals":"function decimals() public view returns (uint8)\nGets the number of decimal places of the token.","return-values#Return Values":"Name\tType\tDescription\t[0]\tuint8\tThe number of decimal places of the token.","source#source":"function source() public view returns (address, uint256)\nGets the source token address and the source chain ID.","return-values-1#Return Values":"Name\tType\tDescription\t[0]\taddress\tThe source token address and the source chain ID.\t[1]\tuint256","title-proxiedbridgederc20#title: ProxiedBridgedERC20":"","proxiedbridgederc20#ProxiedBridgedERC20":""}},"/docs/reference/contract-documentation/bridge/Bridge":{"title":"Bridge","data":{"":"","bridge#Bridge":"This contract is a Bridge contract which is deployed on both L1 and L2. Mostly\na thin wrapper\nwhich calls the library implementations. See IBridge for more details.The code hash for the same address on L1 and L2 may be different.","messagestatuschanged#MessageStatusChanged":"event MessageStatusChanged(bytes32 msgHash, enum LibBridgeStatus.MessageStatus status, address transactor)","destchainenabled#DestChainEnabled":"event DestChainEnabled(uint256 chainId, bool enabled)","receive#receive":"receive() external payable\nAllow Bridge to receive ETH from the DeliteL1, TokenVault or EtherVault.","init#init":"function init(address _addressManager) external\nInitializer to be called after being deployed behind a proxy.Initializer function to setup the EssentialContract.","parameters#Parameters":"Name\tType\tDescription\t_addressManager\taddress\tThe address of the AddressManager contract.","sendmessage#sendMessage":"function sendMessage(struct IBridge.Message message) external payable returns (bytes32 msgHash)\nSends a message from the current chain to the destination chain specified\nin the message.Sends a message by calling the LibBridgeSend.sendMessage library\nfunction.","parameters-1#Parameters":"Name\tType\tDescription\tmessage\tstruct IBridge.Message\tThe message to send. (See IBridge)","return-values#Return Values":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message that was sent.","releaseether#releaseEther":"function releaseEther(struct IBridge.Message message, bytes proof) external\nReleases the Ether locked in the bridge as part of a cross-chain\ntransfer.Releases the Ether by calling the LibBridgeRelease.releaseEther\nlibrary function.","parameters-2#Parameters":"Name\tType\tDescription\tmessage\tstruct IBridge.Message\tThe message containing the details of the Ether transfer. (See IBridge)\tproof\tbytes\tThe proof of the cross-chain transfer.","processmessage#processMessage":"function processMessage(struct IBridge.Message message, bytes proof) external\nProcesses a message received from another chain.Processes the message by calling the LibBridgeProcess.processMessage\nlibrary function.","parameters-3#Parameters":"Name\tType\tDescription\tmessage\tstruct IBridge.Message\tThe message to process.\tproof\tbytes\tThe proof of the cross-chain transfer.","retrymessage#retryMessage":"function retryMessage(struct IBridge.Message message, bool isLastAttempt) external\nRetries sending a message that previously failed to send.Retries the message by calling the LibBridgeRetry.retryMessage\nlibrary function.","parameters-4#Parameters":"Name\tType\tDescription\tmessage\tstruct IBridge.Message\tThe message to retry.\tisLastAttempt\tbool\tSpecifies whether this is the last attempt to send the message.","ismessagesent#isMessageSent":"function isMessageSent(bytes32 msgHash) public view virtual returns (bool)\nCheck if the message with the given hash has been sent.","parameters-5#Parameters":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message.","return-values-1#Return Values":"Name\tType\tDescription\t[0]\tbool\tReturns true if the message has been sent, false otherwise.","ismessagereceived#isMessageReceived":"function isMessageReceived(bytes32 msgHash, uint256 srcChainId, bytes proof) public view virtual returns (bool)\nCheck if the message with the given hash has been received.","parameters-6#Parameters":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message.\tsrcChainId\tuint256\tThe source chain ID.\tproof\tbytes\tThe proof of message receipt.","return-values-2#Return Values":"Name\tType\tDescription\t[0]\tbool\tReturns true if the message has been received, false otherwise.","ismessagefailed#isMessageFailed":"function isMessageFailed(bytes32 msgHash, uint256 destChainId, bytes proof) public view virtual returns (bool)\nCheck if the message with the given hash has failed.","parameters-7#Parameters":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message.\tdestChainId\tuint256\tThe destination chain ID.\tproof\tbytes\tThe proof of message failure.","return-values-3#Return Values":"Name\tType\tDescription\t[0]\tbool\tReturns true if the message has failed, false otherwise.","getmessagestatus#getMessageStatus":"function getMessageStatus(bytes32 msgHash) public view virtual returns (enum LibBridgeStatus.MessageStatus)\nGet the status of the message with the given hash.","parameters-8#Parameters":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message.","return-values-4#Return Values":"Name\tType\tDescription\t[0]\tenum LibBridgeStatus.MessageStatus\tReturns the status of the message.","context#context":"function context() public view returns (struct IBridge.Context)\nGet the current context","return-values-5#Return Values":"Name\tType\tDescription\t[0]\tstruct IBridge.Context\tReturns the current context.","isetherreleased#isEtherReleased":"function isEtherReleased(bytes32 msgHash) public view returns (bool)\nCheck if the Ether associated with the given message hash has been\nreleased.","parameters-9#Parameters":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message.","return-values-6#Return Values":"Name\tType\tDescription\t[0]\tbool\tReturns true if the Ether has been released, false otherwise.","isdestchainenabled#isDestChainEnabled":"function isDestChainEnabled(uint256 _chainId) public view returns (bool enabled)\nCheck if the destination chain with the given ID is enabled.","parameters-10#Parameters":"Name\tType\tDescription\t_chainId\tuint256\tThe ID of the chain.","return-values-7#Return Values":"Name\tType\tDescription\tenabled\tbool\tReturns true if the destination chain is enabled, false otherwise.","hashmessage#hashMessage":"function hashMessage(struct IBridge.Message message) public pure returns (bytes32)\nCompute the hash of a given message.","parameters-11#Parameters":"Name\tType\tDescription\tmessage\tstruct IBridge.Message\tThe message to compute the hash for.","return-values-8#Return Values":"Name\tType\tDescription\t[0]\tbytes32\tReturns the hash of the message.","getmessagestatusslot#getMessageStatusSlot":"function getMessageStatusSlot(bytes32 msgHash) public pure returns (bytes32)\nGet the slot associated with a given message hash status.","parameters-12#Parameters":"Name\tType\tDescription\tmsgHash\tbytes32\tThe hash of the message.","return-values-9#Return Values":"Name\tType\tDescription\t[0]\tbytes32\tReturns the slot associated with the given message hash status.","title-proxiedbridge#title: ProxiedBridge":"","proxiedbridge#ProxiedBridge":""}},"/docs/reference/contract-documentation/bridge/IBridge":{"title":"IBridge","data":{"":"","ibridge#IBridge":"Bridge interface.Ether is held by Bridges on L1 and by the EtherVault on L2,\nnot TokenVaults.","message#Message":"struct Message {\nuint256 id;\naddress sender;\nuint256 srcChainId;\nuint256 destChainId;\naddress owner;\naddress to;\naddress refundAddress;\nuint256 depositValue;\nuint256 callValue;\nuint256 processingFee;\nuint256 gasLimit;\nbytes data;\nstring memo;\n}","context#Context":"struct Context {\nbytes32 msgHash;\naddress sender;\nuint256 srcChainId;\n}","signalsent#SignalSent":"event SignalSent(address sender, bytes32 msgHash)","messagesent#MessageSent":"event MessageSent(bytes32 msgHash, struct IBridge.Message message)","etherreleased#EtherReleased":"event EtherReleased(bytes32 msgHash, address to, uint256 amount)","sendmessage#sendMessage":"function sendMessage(struct IBridge.Message message) external payable returns (bytes32 msgHash)\nSends a message to the destination chain and takes custody\nof Ether required in this contract. All extra Ether will be refunded.","releaseether#releaseEther":"function releaseEther(struct IBridge.Message message, bytes proof) external","ismessagesent#isMessageSent":"function isMessageSent(bytes32 msgHash) external view returns (bool)\nChecks if a msgHash has been stored on the bridge contract by the\ncurrent address.","ismessagereceived#isMessageReceived":"function isMessageReceived(bytes32 msgHash, uint256 srcChainId, bytes proof) external view returns (bool)\nChecks if a msgHash has been received on the destination chain and\nsent by the src chain.","ismessagefailed#isMessageFailed":"function isMessageFailed(bytes32 msgHash, uint256 destChainId, bytes proof) external view returns (bool)\nChecks if a msgHash has been failed on the destination chain.","context-1#context":"function context() external view returns (struct IBridge.Context context)\nReturns the bridge state context.","hashmessage#hashMessage":"function hashMessage(struct IBridge.Message message) external pure returns (bytes32)"}},"/docs/reference/contract-documentation/bridge/BridgeErrors":{"title":"BridgeErrors","data":{"":"","bridgeerrors#BridgeErrors":"","b_cannot_receive#B_CANNOT_RECEIVE":"error B_CANNOT_RECEIVE()\nEmitted when the contract is not intended to receive Ether","b_denied#B_DENIED":"error B_DENIED()\nEmitted when an operation is denied due to incorrect permissions","b_erc20_cannot_receive#B_ERC20_CANNOT_RECEIVE":"error B_ERC20_CANNOT_RECEIVE()\nEmitted when the contract is not designed to receive ERC20 tokens","b_ether_released_already#B_ETHER_RELEASED_ALREADY":"error B_ETHER_RELEASED_ALREADY()\nEmitted when Ether has already been released as part of a transfer","b_ev_do_not_burn#B_EV_DO_NOT_BURN":"error B_EV_DO_NOT_BURN()\nEmitted when attempting to burn Ether in EtherVault","b_ev_not_authorized#B_EV_NOT_AUTHORIZED":"error B_EV_NOT_AUTHORIZED()\nEmitted when an unauthorized action is attempted in EtherVault","b_ev_param#B_EV_PARAM":"error B_EV_PARAM()\nEmitted when an incorrect parameter is passed in EtherVault","b_failed_transfer#B_FAILED_TRANSFER":"error B_FAILED_TRANSFER()\nEmitted when an ERC20 token transfer fails","b_forbidden#B_FORBIDDEN":"error B_FORBIDDEN()\nEmitted when an action is forbidden","b_gas_limit#B_GAS_LIMIT":"error B_GAS_LIMIT()\nEmitted when the gas limit for an operation is exceeded","b_incorrect_value#B_INCORRECT_VALUE":"error B_INCORRECT_VALUE()\nEmitted when an incorrect value is used in an operation","b_init_param_error#B_INIT_PARAM_ERROR":"error B_INIT_PARAM_ERROR()\nEmitted when an incorrect parameter is passed during initialization","b_msg_hash_null#B_MSG_HASH_NULL":"error B_MSG_HASH_NULL()\nEmitted when a null message hash is used","b_msg_non_retriable#B_MSG_NON_RETRIABLE":"error B_MSG_NON_RETRIABLE()\nEmitted when a non-retriable message is retried","b_msg_not_failed#B_MSG_NOT_FAILED":"error B_MSG_NOT_FAILED()\nEmitted when a message that hasn't failed is retried","b_null_app_addr#B_NULL_APP_ADDR":"error B_NULL_APP_ADDR()\nEmitted when a null address is used in an application","b_owner_is_null#B_OWNER_IS_NULL":"error B_OWNER_IS_NULL()\nEmitted when a null owner address is used","b_signal_not_received#B_SIGNAL_NOT_RECEIVED":"error B_SIGNAL_NOT_RECEIVED()\nEmitted when a signal has not been received","b_status_mismatch#B_STATUS_MISMATCH":"error B_STATUS_MISMATCH()\nEmitted when the status of an operation does not match the expected\nstatus","b_wrong_chain_id#B_WRONG_CHAIN_ID":"error B_WRONG_CHAIN_ID()\nEmitted when an incorrect chain ID is used","b_wrong_to_address#B_WRONG_TO_ADDRESS":"error B_WRONG_TO_ADDRESS()\nEmitted when an incorrect recipient address is used","b_zero_signal#B_ZERO_SIGNAL":"error B_ZERO_SIGNAL()\nEmitted when a signal of zero is used"}},"/docs/reference/contract-documentation/L1/TaikoToken":{"title":"LibDeliteTokenConfig","data":{"":"","libdelitetokenconfig#LibDeliteTokenConfig":"","decimals#DECIMALS":"uint8 DECIMALS","title-delitetoken#title: DeliteToken":"","delitetoken#DeliteToken":"","mint#Mint":"event Mint(address account, uint256 amount)","burn#Burn":"event Burn(address account, uint256 amount)","tko_invalid_addr#TKO_INVALID_ADDR":"error TKO_INVALID_ADDR()","tko_invalid_premint_params#TKO_INVALID_PREMINT_PARAMS":"error TKO_INVALID_PREMINT_PARAMS()","tko_mint_disallowed#TKO_MINT_DISALLOWED":"error TKO_MINT_DISALLOWED()","init#init":"function init(address _addressManager, string _name, string _symbol, address[] _premintRecipients, uint256[] _premintAmounts) public","snapshot#snapshot":"function snapshot() public","pause#pause":"function pause() public","unpause#unpause":"function unpause() public","mint-1#mint":"function mint(address to, uint256 amount) public","burn-1#burn":"function burn(address from, uint256 amount) public","transfer#transfer":"function transfer(address to, uint256 amount) public returns (bool)\n_See {IERC20-transfer}.Requirements:\nto cannot be the zero address.\nthe caller must have a balance of at least amount._","transferfrom#transferFrom":"function transferFrom(address from, address to, uint256 amount) public returns (bool)\n_See {IERC20-transferFrom}.Emits an {Approval} event indicating the updated allowance. This is not\nrequired by the EIP. See the note at the beginning of {ERC20}.NOTE: Does not update the allowance if the current allowance\nis the maximum uint256.Requirements:\nfrom and to cannot be the zero address.\nfrom must have a balance of at least amount.\nthe caller must have allowance for from's tokens of at least\namount._","decimals-1#decimals":"function decimals() public pure returns (uint8)\n_Returns the number of decimals used to get its user representation.\nFor example, if decimals equals 2, a balance of 505 tokens should\nbe displayed to a user as 5.05 (505 / 10 ** 2).Tokens usually opt for a value of 18, imitating the relationship between\nEther and Wei. This is the value {ERC20} uses, unless this function is\noverridden;NOTE: This information is only used for display purposes: it in\nno way affects any of the arithmetic of the contract, including\n{IERC20-balanceOf} and {IERC20-transfer}._","_beforetokentransfer#_beforeTokenTransfer":"function _beforeTokenTransfer(address from, address to, uint256 amount) internal","_aftertokentransfer#_afterTokenTransfer":"function _afterTokenTransfer(address from, address to, uint256 amount) internal","_mint#_mint":"function _mint(address to, uint256 amount) internal","_burn#_burn":"function _burn(address from, uint256 amount) internal","title-proxieddelitetoken#title: ProxiedDeliteToken":"","proxieddelitetoken#ProxiedDeliteToken":""}},"/docs/reference/contract-documentation/common/AddressManager":{"title":"IAddressManager","data":{"":"","iaddressmanager#IAddressManager":"Interface to set and get an address for a name.","setaddress#setAddress":"function setAddress(uint256 domain, bytes32 name, address newAddress) external\nChanges the address associated with a particular name.","parameters#Parameters":"Name\tType\tDescription\tdomain\tuint256\tUint256 domain to assiciate an address with.\tname\tbytes32\tName to associate an address with.\tnewAddress\taddress\tAddress to associate with the name.","getaddress#getAddress":"function getAddress(uint256 domain, bytes32 name) external view returns (address)\nRetrieves the address associated with a given name.","parameters-1#Parameters":"Name\tType\tDescription\tdomain\tuint256\tClass to retrieve an address for.\tname\tbytes32\tName to retrieve an address for.","return-values#Return Values":"Name\tType\tDescription\t[0]\taddress\tAddress associated with the given name.","title-addressmanager#title: AddressManager":"","addressmanager#AddressManager":"","addressset#AddressSet":"event AddressSet(uint256 _domain, bytes32 _name, address _newAddress, address _oldAddress)","eoaowneraddressnotallowed#EOAOwnerAddressNotAllowed":"error EOAOwnerAddressNotAllowed()","init#init":"function init() external\nInitializer to be called after being deployed behind a proxy.","setaddress-1#setAddress":"function setAddress(uint256 domain, bytes32 name, address newAddress) external virtual\nChanges the address associated with a particular name.","parameters-2#Parameters":"Name\tType\tDescription\tdomain\tuint256\tUint256 domain to assiciate an address with.\tname\tbytes32\tName to associate an address with.\tnewAddress\taddress\tAddress to associate with the name.","getaddress-1#getAddress":"function getAddress(uint256 domain, bytes32 name) external view virtual returns (address addr)\nRetrieves the address associated with a given name.","parameters-3#Parameters":"Name\tType\tDescription\tdomain\tuint256\tClass to retrieve an address for.\tname\tbytes32\tName to retrieve an address for.","return-values-1#Return Values":"Name\tType\tDescription\taddr\taddress\tAddress associated with the given name.","title-proxiedaddressmanager#title: ProxiedAddressManager":"","proxiedaddressmanager#ProxiedAddressManager":""}},"/docs/reference/contract-documentation/bridge/TokenVault":{"title":"TokenVault","data":{"":"","tokenvault#TokenVault":"This vault holds all ERC20 tokens (but not Ether) that users have deposited.\nIt also manages the mapping between canonical ERC20 tokens and their bridged\ntokens.Ether is held by Bridges on L1 and by the EtherVault on L2, not\nTokenVaults.","canonicalerc20#CanonicalERC20":"struct CanonicalERC20 {\nuint256 chainId;\naddress addr;\nuint8 decimals;\nstring symbol;\nstring name;\n}","messagedeposit#MessageDeposit":"struct MessageDeposit {\naddress token;\nuint256 amount;\n}","isbridgedtoken#isBridgedToken":"mapping(address => bool) isBridgedToken","bridgedtocanonical#bridgedToCanonical":"mapping(address => struct TokenVault.CanonicalERC20) bridgedToCanonical","canonicaltobridged#canonicalToBridged":"mapping(uint256 => mapping(address => address)) canonicalToBridged","messagedeposits#messageDeposits":"mapping(bytes32 => struct TokenVault.MessageDeposit) messageDeposits","bridgederc20deployed#BridgedERC20Deployed":"event BridgedERC20Deployed(uint256 srcChainId, address canonicalToken, address bridgedToken, string canonicalTokenSymbol, string canonicalTokenName, uint8 canonicalTokenDecimal)","ethersent#EtherSent":"event EtherSent(bytes32 msgHash, address from, address to, uint256 destChainId, uint256 amount)","erc20sent#ERC20Sent":"event ERC20Sent(bytes32 msgHash, address from, address to, uint256 destChainId, address token, uint256 amount)","erc20released#ERC20Released":"event ERC20Released(bytes32 msgHash, address from, address token, uint256 amount)","erc20received#ERC20Received":"event ERC20Received(bytes32 msgHash, address from, address to, uint256 srcChainId, address token, uint256 amount)","tokenvault_invalid_to#TOKENVAULT_INVALID_TO":"error TOKENVAULT_INVALID_TO()\nThrown when the to address in an operation is invalid.\nThis can happen if it's zero address or the address of the token vault.","tokenvault_invalid_value#TOKENVAULT_INVALID_VALUE":"error TOKENVAULT_INVALID_VALUE()\nThrown when the value in a transaction is invalid.\nThe value can be an Ether amount or the amount of a token being\ntransferred.","tokenvault_invalid_token#TOKENVAULT_INVALID_TOKEN":"error TOKENVAULT_INVALID_TOKEN()\nThrown when the token address in a transaction is invalid.\nThis could happen if the token address is zero or doesn't conform to the\nERC20 standard.","tokenvault_invalid_amount#TOKENVAULT_INVALID_AMOUNT":"error TOKENVAULT_INVALID_AMOUNT()\nThrown when the amount in a transaction is invalid.\nThis could happen if the amount is zero or exceeds the sender's balance.","tokenvault_canonical_token_not_found#TOKENVAULT_CANONICAL_TOKEN_NOT_FOUND":"error TOKENVAULT_CANONICAL_TOKEN_NOT_FOUND()\nThrown when a canonical token address could not be found for a bridged\ntoken.\nThis could happen when trying to send a bridged token back to its\noriginal chain.","tokenvault_invalid_owner#TOKENVAULT_INVALID_OWNER":"error TOKENVAULT_INVALID_OWNER()\nThrown when the owner address in a message is invalid.\nThis could happen if the owner address is zero or doesn't match the\nexpected owner.","tokenvault_invalid_src_chain_id#TOKENVAULT_INVALID_SRC_CHAIN_ID":"error TOKENVAULT_INVALID_SRC_CHAIN_ID()\nThrown when the source chain ID in a message is invalid.\nThis could happen if the source chain ID doesn't match the current\nchain's ID.","tokenvault_message_not_failed#TOKENVAULT_MESSAGE_NOT_FAILED":"error TOKENVAULT_MESSAGE_NOT_FAILED()\nThrown when a message has not failed.\nThis could happen if trying to release a message deposit without proof of\nfailure.","tokenvault_invalid_sender#TOKENVAULT_INVALID_SENDER":"error TOKENVAULT_INVALID_SENDER()\nThrown when the sender in a message context is invalid.\nThis could happen if the sender isn't the expected token vault on the\nsource chain.","init#init":"function init(address addressManager) external","senderc20#sendERC20":"function sendERC20(uint256 destChainId, address to, address token, uint256 amount, uint256 gasLimit, uint256 processingFee, address refundAddress, string memo) external payable\nTransfers ERC20 tokens to this vault and sends a message to the\ndestination chain so the user can receive the same amount of tokens\nby invoking the message call.","parameters#Parameters":"Name\tType\tDescription\tdestChainId\tuint256\tChain ID of the destination chain\tto\taddress\tAddress of the receiver\ttoken\taddress\tThe address of the token to be sent.\tamount\tuint256\tThe amount of token to be transferred.\tgasLimit\tuint256\tGas limit for the transaction\tprocessingFee\tuint256\tProcessing fee for the transaction\trefundAddress\taddress\tAddress for refunds\tmemo\tstring\tAny additional data or notes","releaseerc20#releaseERC20":"function releaseERC20(struct IBridge.Message message, bytes proof) external\nRelease deposited ERC20 back to the owner on the source TokenVault with\na proof that the message processing on the destination Bridge has failed.","parameters-1#Parameters":"Name\tType\tDescription\tmessage\tstruct IBridge.Message\tThe message that corresponds to the ERC20 deposit on the source chain.\tproof\tbytes\tThe proof from the destination chain to show the message has failed.","receiveerc20#receiveERC20":"function receiveERC20(struct TokenVault.CanonicalERC20 canonicalToken, address from, address to, uint256 amount) external\nThis function can only be called by the bridge contract while\ninvoking a message call. See sendERC20, which sets the data to invoke\nthis function.","parameters-2#Parameters":"Name\tType\tDescription\tcanonicalToken\tstruct TokenVault.CanonicalERC20\tThe canonical ERC20 token which may or may not live on this chain. If not, a BridgedERC20 contract will be deployed.\tfrom\taddress\tThe source address.\tto\taddress\tThe destination address.\tamount\tuint256\tThe amount of tokens to be sent. 0 is a valid value.","title-proxiedtokenvault#title: ProxiedTokenVault":"","proxiedtokenvault#ProxiedTokenVault":""}},"/docs/reference/contract-documentation/bridge/EtherVault":{"title":"EtherVault","data":{"":"","ethervault#EtherVault":"This contract is initialized with 2^128 Ether and allows authorized addresses\nto release Ether.Only the contract owner can authorize or deauthorize addresses.","authorized#Authorized":"event Authorized(address addr, bool authorized)","etherreleased#EtherReleased":"event EtherReleased(address to, uint256 amount)","onlyauthorized#onlyAuthorized":"modifier onlyAuthorized()","receive#receive":"receive() external payable\nFunction to receive EtherOnly authorized addresses can send Ether to the contract","init#init":"function init(address addressManager) external\nInitialize the contract with an address manager","parameters#Parameters":"Name\tType\tDescription\taddressManager\taddress\tThe address of the address manager","releaseether#releaseEther":"function releaseEther(uint256 amount) public\nTransfer Ether from EtherVault to the sender, checking that the sender\nis authorized.","parameters-1#Parameters":"Name\tType\tDescription\tamount\tuint256\tAmount of Ether to send.","releaseether-1#releaseEther":"function releaseEther(address recipient, uint256 amount) public\nTransfer Ether from EtherVault to a designated address, checking that the\nsender is authorized.","parameters-2#Parameters":"Name\tType\tDescription\trecipient\taddress\tAddress to receive Ether.\tamount\tuint256\tAmount of ether to send.","authorize#authorize":"function authorize(address addr, bool authorized) public\nSet the authorized status of an address, only the owner can call this.","parameters-3#Parameters":"Name\tType\tDescription\taddr\taddress\tAddress to set the authorized status of.\tauthorized\tbool\tAuthorized status to set.","isauthorized#isAuthorized":"function isAuthorized(address addr) public view returns (bool)\nGet the authorized status of an address.","parameters-4#Parameters":"Name\tType\tDescription\taddr\taddress\tAddress to get the authorized status of.","title-proxiedethervault#title: ProxiedEtherVault":"","proxiedethervault#ProxiedEtherVault":""}},"/docs/reference/contract-documentation/common/ICrossChainSync":{"title":"ICrossChainSync","data":{"":"","icrosschainsync#ICrossChainSync":"Interface implemented by both the DeliteL1 and DeliteL2 contracts. It exposes\nthe methods needed to access the block hashes of the other chain.","crosschainsynced#CrossChainSynced":"event CrossChainSynced(uint256 srcHeight, bytes32 blockHash, bytes32 signalRoot)","getcrosschainblockhash#getCrossChainBlockHash":"function getCrossChainBlockHash(uint256 number) external view returns (bytes32)\nReturns the cross-chain block hash at the given block number.","parameters#Parameters":"Name\tType\tDescription\tnumber\tuint256\tThe block number. Use 0 for the latest block.","return-values#Return Values":"Name\tType\tDescription\t[0]\tbytes32\tThe cross-chain block hash.","getcrosschainsignalroot#getCrossChainSignalRoot":"function getCrossChainSignalRoot(uint256 number) external view returns (bytes32)\nReturns the cross-chain signal service storage root at the given\nblock number.","parameters-1#Parameters":"Name\tType\tDescription\tnumber\tuint256\tThe block number. Use 0 for the latest block.","return-values-1#Return Values":"Name\tType\tDescription\t[0]\tbytes32\tThe cross-chain signal service storage root."}},"/docs/reference/contract-documentation/common/AddressResolver":{"title":"AddressResolver","data":{"":"","addressresolver#AddressResolver":"This abstract contract provides a name-to-address lookup. Under the hood,\nit uses an AddressManager to manage the name-to-address mapping.","_addressmanager#_addressManager":"contract IAddressManager _addressManager","addressmanagerchanged#AddressManagerChanged":"event AddressManagerChanged(address addressManager)","resolver_denied#RESOLVER_DENIED":"error RESOLVER_DENIED()","resolver_invalid_addr#RESOLVER_INVALID_ADDR":"error RESOLVER_INVALID_ADDR()","resolver_zero_addr#RESOLVER_ZERO_ADDR":"error RESOLVER_ZERO_ADDR(uint256 chainId, bytes32 name)","onlyfromnamed#onlyFromNamed":"modifier onlyFromNamed(bytes32 name)","resolve#resolve":"function resolve(bytes32 name, bool allowZeroAddress) public view virtual returns (address payable)\nResolves a name to an address on the current chain.This function will throw if the resolved address is address(0).","parameters#Parameters":"Name\tType\tDescription\tname\tbytes32\tThe name to resolve.\tallowZeroAddress\tbool\tTrue to allow zero address to be returned.","return-values#Return Values":"Name\tType\tDescription\t[0]\taddress payable\tThe name's corresponding address.","resolve-1#resolve":"function resolve(uint256 chainId, bytes32 name, bool allowZeroAddress) public view virtual returns (address payable)\nResolves a name to an address on the specified chain.This function will throw if the resolved address is address(0).","parameters-1#Parameters":"Name\tType\tDescription\tchainId\tuint256\tThe chainId.\tname\tbytes32\tThe name to resolve.\tallowZeroAddress\tbool\tTrue to allow zero address to be returned.","return-values-1#Return Values":"Name\tType\tDescription\t[0]\taddress payable\tThe name's corresponding address.","addressmanager#addressManager":"function addressManager() public view returns (address)\nReturns the AddressManager's address.","return-values-2#Return Values":"Name\tType\tDescription\t[0]\taddress\tThe AddressManager's address.","_init#_init":"function _init(address addressManager_) internal virtual"}},"/docs/reference/contract-documentation/common/IMintableERC20":{"title":"IMintableERC20","data":{"":"","imintableerc20#IMintableERC20":"","mint#mint":"function mint(address account, uint256 amount) external","burn#burn":"function burn(address account, uint256 amount) external"}},"/docs/reference/contract-documentation/common/Proxied":{"title":"Proxied","data":{"":"","proxied#Proxied":"","constructor#constructor":"constructor() internal"}},"/docs/reference/contract-documentation/gov/TaikoGovernor":{"title":"DeliteGovernor","data":{"":"","delitegovernor#DeliteGovernor":"","init#init":"function init(address _addressManager, contract IVotesUpgradeable _token, contract TimelockControllerUpgradeable _timelock) public","propose#propose":"function propose(address[] targets, uint256[] values, bytes[] calldatas, string description) public returns (uint256)","votingdelay#votingDelay":"function votingDelay() public view returns (uint256)","votingperiod#votingPeriod":"function votingPeriod() public view returns (uint256)","quorum#quorum":"function quorum(uint256 blockNumber) public view returns (uint256)","state#state":"function state(uint256 proposalId) public view returns (enum IGovernorUpgradeable.ProposalState)","proposalthreshold#proposalThreshold":"function proposalThreshold() public view returns (uint256)","supportsinterface#supportsInterface":"function supportsInterface(bytes4 interfaceId) public view returns (bool)","_execute#_execute":"function _execute(uint256 proposalId, address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash) internal","_cancel#_cancel":"function _cancel(address[] targets, uint256[] values, bytes[] calldatas, bytes32 descriptionHash) internal returns (uint256)","_executor#_executor":"function _executor() internal view returns (address)","title-proxieddelitegovernor#title: ProxiedDeliteGovernor":"","proxieddelitegovernor#ProxiedDeliteGovernor":""}},"/docs/reference/contract-documentation/signal/SignalService":{"title":"SignalService","data":{"":"","signalservice#SignalService":"","signalproof#SignalProof":"struct SignalProof {\nuint256 height;\nbytes proof;\n}","b_zero_signal#B_ZERO_SIGNAL":"error B_ZERO_SIGNAL()","b_null_app_addr#B_NULL_APP_ADDR":"error B_NULL_APP_ADDR()","b_wrong_chain_id#B_WRONG_CHAIN_ID":"error B_WRONG_CHAIN_ID()","init#init":"function init(address _addressManager) external\nInitializer to be called after being deployed behind a proxy.","sendsignal#sendSignal":"function sendSignal(bytes32 signal) public returns (bytes32 storageSlot)\nSend a signal by storing the key with a value of 1.","parameters#Parameters":"Name\tType\tDescription\tsignal\tbytes32\tThe signal to send.","return-values#Return Values":"Name\tType\tDescription\tstorageSlot\tbytes32\tThe slot in storage that this signal is persisted.","issignalsent#isSignalSent":"function isSignalSent(address app, bytes32 signal) public view returns (bool)\nCheck if a signal has been sent (key stored with a value of 1).","parameters-1#Parameters":"Name\tType\tDescription\tapp\taddress\tThe address that sent this message.\tsignal\tbytes32\tThe signal to check.","issignalreceived#isSignalReceived":"function isSignalReceived(uint256 srcChainId, address app, bytes32 signal, bytes proof) public view returns (bool)\nCheck if signal has been received on the destination chain (current).","parameters-2#Parameters":"Name\tType\tDescription\tsrcChainId\tuint256\tThe source chain ID.\tapp\taddress\tThe address that sent this message.\tsignal\tbytes32\tThe signal to check.\tproof\tbytes\tThe proof of the signal being sent on the source chain.","getsignalslot#getSignalSlot":"function getSignalSlot(address app, bytes32 signal) public pure returns (bytes32 signalSlot)","parameters-3#Parameters":"Name\tType\tDescription\tapp\taddress\tThe srcAddress of the app (eg. the Bridge).\tsignal\tbytes32\tThe signal to store.","return-values-1#Return Values":"Name\tType\tDescription\tsignalSlot\tbytes32\tThe storage key for the signal on the signal service.","title-proxiedsignalservice#title: ProxiedSignalService":"","proxiedsignalservice#ProxiedSignalService":""}},"/docs/reference/rpc-configuration":{"title":"RPC configuration","data":{"":"Network\tChain ID\tRPC URL\tSymbol\tBlock Explorer URL\tSepolia\t11155111\thttps://rpc.sepolia.org\tETH\thttps://sepolia.etherscan.io/\tDelite\t167005\thttps://rpc.test.delite.xyz\tETH\thttps://explorer.test.delite.xyz"}},"/docs/reference/contract-documentation/signal/ISignalService":{"title":"ISignalService","data":{"":"","isignalservice#ISignalService":"","sendsignal#sendSignal":"function sendSignal(bytes32 signal) external returns (bytes32 storageSlot)\nSend a signal by storing the key with a value of 1.","parameters#Parameters":"Name\tType\tDescription\tsignal\tbytes32\tThe signal to send.","return-values#Return Values":"Name\tType\tDescription\tstorageSlot\tbytes32\tThe slot in storage that this signal is persisted.","issignalsent#isSignalSent":"function isSignalSent(address app, bytes32 signal) external view returns (bool)\nCheck if a signal has been sent (key stored with a value of 1).","parameters-1#Parameters":"Name\tType\tDescription\tapp\taddress\tThe address that sent this message.\tsignal\tbytes32\tThe signal to check.","issignalreceived#isSignalReceived":"function isSignalReceived(uint256 srcChainId, address app, bytes32 signal, bytes proof) external view returns (bool)\nCheck if signal has been received on the destination chain (current).","parameters-2#Parameters":"Name\tType\tDescription\tsrcChainId\tuint256\tThe source chain ID.\tapp\taddress\tThe address that sent this message.\tsignal\tbytes32\tThe signal to check.\tproof\tbytes\tThe proof of the signal being sent on the source chain."}},"/docs/resources/rollup-glossary":{"title":"Rollup glossary","data":{"":"View the community Rollup Glossary."}},"/docs/resources/official-links":{"title":"Official links","data":{"":"Name\tLink\tBlog\thttps://mirror.xyz/labs.delite.eth\tCommunity forum\thttps://community.delite.xyz/\tDiscord\thttps://discord.gg/delitesystems\tDocumentation\thttps://delite.xyz/docs\tGitHub\thttps://github.com/delitesystems\tHackMd\thttps://hackmd.io/@delitelabs\tReddit\thttps://www.reddit.com/r/delite_xyz\tTwitter\thttps://twitter.com/delitesystems\tWebsite\thttps://delite.xyz\tWhitepaper\thttps://delitesystems.github.io/delite-mono/delite-whitepaper.pdf\tYouTube\thttps://www.youtube.com/@delitesystems"}},"/":{"title":"Home","data":{"":""}},"/docs/resources/contributing":{"title":"Contributing","data":{"":"Community contributions are very encouraged! View the contributing guide to learn more."}},"/docs/resources/whitepaper":{"title":"Whitepaper","data":{"":"Read about the Delite protocol in depth with the whitepaper."}},"/docs/resources/talks":{"title":"Talks","data":{"":"You can find our other talks (e.g., Tea with Delite, Community Call) on our YouTube!","presentations#Presentations":"Date\tTitle\tVideo\tSlides\tEvent\tLocation\t2023-04-14\tWhat's Delite, Why Delite?\tYouTube\tHackMd\tETHGlobal Tokyo\tTokyo, Japan\t2023-04-14\tIntro to Delite: Using Ethereum-equivalence for ZK-EVM superpowers\tYouTube\tHackMd\tETHGlobal Tokyo Workshop\tTokyo, Japan\t2023-04-08\tDecentralized, Ethereum-equivalent ZK Rollup\tYouTube\tHackMd\tETHGlobal Tokyo Builders Session\tTokyo, Japan\t2023-03-14\tIntroduction to Delite + Ethereum Dapp Speedrun with SvelteKit and Foundry\tYouTube\tDrive\tScaling Ethereum — ETHGlobal\tOnline\t2023-03-01\tDelite ZK-EVM: Inheriting Layer 1 Security\tYouTube\tHackMd\tSecurity Day — ETHDenver\tDenver, Colorado\t2022-11-21\tDelite Protocol Explained\tYouTube\t-\tInternal presentation by Delite co-founder Daniel Wang\tOnline\t2022-11-01\tDelite ZK-EVM: Layer 2 Finality\tYouTube\tHackMd\tOld Friends Reunion — ETH Lisbon\tLisbon, Portugal\t2022-10-10\tDelite ZK-EVM: Overview and Optimizations\t-\tHackMd\tRollup Day — Devcon VI\tBogota, Colombia","twitter-spaces#Twitter spaces":"Date\tTitle\tLink\t2022-02-10\tDeep Dive in Delite\tTwitter"}},"/docs/reference/contract-documentation/L1/TaikoEvents":{"title":"DeliteEvents","data":{"":"","deliteevents#DeliteEvents":"","blockproposed#BlockProposed":"event BlockProposed(uint256 id, struct DeliteData.BlockMetadata meta, uint64 blockFee)","blockproven#BlockProven":"event BlockProven(uint256 id, bytes32 parentHash, bytes32 blockHash, bytes32 signalRoot, address prover, uint32 parentGasUsed)","blockverified#BlockVerified":"event BlockVerified(uint256 id, bytes32 blockHash, uint64 reward)","ethdeposited#EthDeposited":"event EthDeposited(struct DeliteData.EthDeposit deposit)","proofparamschanged#ProofParamsChanged":"event ProofParamsChanged(uint64 proofTimeTarget, uint64 proofTimeIssued, uint64 blockFee, uint16 adjustmentQuotient)"}},"/ecosystem":{"title":"Ecosystem","data":{"":""}}}